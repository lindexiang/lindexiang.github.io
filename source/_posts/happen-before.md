---
title: Happens-Before
date: 2018-08-25 15:30:05
tags: 
    - JVM
    - 线程同步
    - 内存可见性
categories: JVM虚拟机原理
image: http://pbhb4py13.bkt.clouddn.com/wallls.com_175256.jpg

---
## happens-before简介
在看JVM的内存模型时对内存可见性一直有个问题，线程A锁住，更新了对象内容A，释放锁，线程B锁住，为什么能获得对象A的最新值。还有双重检查生成单例时为什么需要把instance设置成violatile。问题的本质是线程同步的原子性，可见性，有序性的实现原理。我在看了
http://ifeve.com/java-%E4%BD%BF%E7%94%A8-happen-before-%E8%A7%84%E5%88%99%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C/ 这个文章后有一种恍然大悟的感觉，终于搞明白了。
<!--more-->
在深入理解JVM虚拟机文章中说过一句话，JMM(java内存模型)中的happens-before(hb规则)规则定义了java多线程操作的有序性和可见性，防止编译器重排序对结果的影响。 官方文档说:

>一个变量被多个线程读取并且至少被一个线程写入时，如果读操作和写操作没有HB规则，那么将会产生数据竞争问题。为了保证操作B能看到操作A的结果(无论A和B是否在一个线程)，那么A和B之间必须满足HB规则，如果没有，将会导致重排序。

总结起来就是2点

* 如果满足HB规则，那么能保证可见性和有序性。比如线程加锁，同一个锁时，顺序为线程A-线程B，那么线程B一定能看到线程A的任何修改结果。缓存和主内存之间的关系会失效。
* HB规则的实现原理具体我也不知道，好像是根据CPU总线事务来操作的。只要知道HB规则会使缓存失效。

## 缓存一致性和java内存模型(JMM java memory model)

> 在谈论java线程模型时必须要了解缓存一致性原则，这个是java内存模型的基础。java内存模型是一个概念模型，底层是寄存器、缓存内存、主内存、CPU之间的互相协作。

在多处理器的情况下，共享数据的交互硬件之间的关系如下:
![](http://pbhb4py13.bkt.clouddn.com/15351845594543.jpg)
JMM
![](http://pbhb4py13.bkt.clouddn.com/15351846294119.jpg)

### 缓存一致性协议(MESI)
每个CPU都有属于自己的高速缓存，在需要同步的情况下，如果在缓存中更新了数据后，其他CPU读取该共享变量的缓存后就会出现**缓存不一致**的错误。这个时候就需要MESI协议来实现缓存一致性。
可以采用LOCK#信号来对总线进行锁定，一个CPU在总线上输出该信号后，其他CPU的请求将会被阻塞，则该CPU可以独自共享内存，但是该方法的开销太大，之后的计算机一般采用**缓存锁定**的方式。
MESI代表缓存数据的4种状态的名字，分别为Modified, Exclusive, Shared, Invalid

- Modified <br />
被修改的缓存。该缓存在本CPU中有缓存数据,其他CPU中没有，对其他缓存中的值是已经被修改过的，但是没有更新到内存中。
- Exclusive <br />
独占的。处于该状态的缓存，在本CPU中有缓存，并且数据没有修改，在内存中一致。
- Shared <br />
共享的。处于这个状态的数据在多个CPU中都有缓存，且和内存一致。
-Invalid <br />
失效的数据。缓存的数据已经失效，或者不在缓存中。

>嗅探技术：嗅探能够嗅探到其他处理器访问主内存和它们的内存缓存

缓存行在以上的4种状态的基础上，通过“嗅探”的技术完成以下功能 

- 一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主内存地址的值，如果监听到，则必须在此操作执行前将缓存行写回CPU中。
- 处于S状态的缓存行，必须监听使该缓存行无效或者独占该缓存行的请求，监听到后将该缓存行设置为I
- 处于E状态，必须监听其他试图读取该缓存行的主内存地址的操作，监听到，将该缓存行的状态设置为S
- 只有E和M状态可以进行写操作并且不需要额外操作，想要对S状态的缓存字段写操作，先发送一个RFO广播，该广播可以让其他CPU缓存中的相同的字段的状态变成I

通过以上的机制可以保证处理器的读写操作是原子性的，并且读到的数据都是最新的，即内存可见性。

> 总结以上的**EMSI协议，其实就是能通过使缓存失效和读取变量强制从主内存中读取的方式来保证了内存的可见性**。类似的，java中的锁和violatile也是这样的原理.

### java并发编程中的几个原则
> 在使用synchorized和RenntrantLock时，我们只关注了它们的原子性，其实它们的可见性和有序性更加的重要。可见性保证了同步的两个线程读取的变量的是最新值。有序性保证了线程的先后顺序。原子性就是你们所理解的那样子。

1. 原子性 <br />
Java主要提供了**锁机制以及CAS操作实现原子性**，对于单个读/写操作是通过LOCK#信号或“缓存锁定”实现的。 除此之外，long和double类型的变量读/写是非原子性的，每次都只读/写32位数据，所以一个单个的读/写操作就变成了两个读/写操作，有可能在只读/写了其中32位操作后CPU就被其他线程抢占到。
2. 可见性 <br />
每个线程都有私有的缓存。java中提供了violatile保证了内存的可见性，底层通过了Lock#或者缓存锁定实现。

3. 有序性 <br />
编译器和处理器会对代码进行排序，排序包括了 1. 语句的执行顺序重排序。 2.指令集并行的重排序，多个CPU协同读取 3.内存系统的重排序 缓存和内存的数据同步存在时间差。

### 内存屏障
内存屏障是一个CPU指令，java编译器会在生成指令的适当位置插入内存屏障指令来禁止特定类型的处理器重排序，作用有2个:

https://blog.csdn.net/sdr_zd/article/details/81323519


