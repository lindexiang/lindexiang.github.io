---
title: LINUX的IO模型
date: 2018-10-21 19:40:15
tags: 
    - IO模型
    - BIO
    - NIO
    - AIO
    - 同步
    - 异步
    - 阻塞
    - 非阻塞
    - socket编程
categories: socket编程
image: http://pbhb4py13.bkt.clouddn.com/2018-08-30-david-beatz-798135-unsplash.jpg
top : 100

---
# LINUX的5种IO模型
## 简介
同步阻塞，同步非阻塞，异步阻塞，异步非阻塞这些不同的IO模型是如何定义的。在看了几篇博客后我总结了下，把自己说服通了。
<!-- more -->
服务端的应用程序要响应客户端的请求时，要有IO请求。在网络IO中，首先，内核会先收集完整的TCP或者UDP数据包，再将数据从内核复制到用户的内存中。这里的IO模型是针对于服务器端的，因为客户端一般都是阻塞的。
**操作系统是分为用户空间和内核空间。是由操作系统来获取网络中的IO请求和获取数据。用户的程序是通过系统调用来获取内核中的IO请求数据。**
**对于一个网络IO的情况，它会涉及到两个系统对象，一个是调用这个IO的进程或者线程，另一个就是系统内核(kernel)**。当一个read操作发生时，它会经历两个阶段：
 1 等待数据准备   
 2 将数据从内核拷贝到进程中 
记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。
UNIX提供了5种的IO模型，任何的IO请求一定是这5种中的一种。
## 阻塞IO模型 BIO 
在默认的情况下，BIO的操作均是阻塞的。
比如I/O模型下的套接字接口，进程空间recvfrom类似于`socket.accept()`，其系统调用直到数据包到达并且被复制到应用进程的缓冲区或者错误时才返回，在此期间一直等待。
进程在调用recvform开始直到返回的整段时间都是被阻塞的。
![2FC922B4-26BA-4887-82C2-928B3B38C773](http://pbhb4py13.bkt.clouddn.com/2018-10-21-2FC922B4-26BA-4887-82C2-928B3B38C773.png)
当用户进程recvfrom这个系统调用时候，kernal就开始IO的第一个阶段：准备数据。对于network io来说，很多时候数据还没有到达（比如没有收到完整的UDP包），kerna要等到收到足够的数据。而在用户进程这边，整个进程都会被阻塞。当kernal把数据准备好，它会将数据从kernal拷贝到用户内存中，然后kernal返回结果，用户进程菜解除block状态。
BIO在执行IO的两个阶段都被block了。
     
## 非阻塞IO模型 NIO
用户进程在recvfrom的时候，如果数据没有准备好，那么操作系统直接返回一个错误，一般非阻塞IO都会轮训去检查这个状态，看内核中是否已经准备好数据。从用户的角度看，当它发起一个read IO操作后，并没有等待，而是立马得到一个返回结果，用户知道了数据没有准备好，等过段时间再发起read请求。一旦kernel准备好了数据，并且收到了用户的read请求，就会将数据从kernel拷贝到用户内存。用户的进程在不断询问kernel数据是否准备好。
![](http://pbhb4py13.bkt.clouddn.com/15407792094650.jpg)
## 信号驱动IO
开启套接字信号驱动IO功能，并通过系统调用signalaction来执行一个信号处理函数(系统调用立即返回，进程继续工作，非阻塞)当有数据到达时候，为进程生成一个signal信号，通过信号应用程序调用recvfrom来读取数据。
![63FADCFE-4EF5-4055-B2AF-B76B3594494B](http://pbhb4py13.bkt.clouddn.com/2018-10-21-63FADCFE-4EF5-4055-B2AF-B76B3594494B.png)
## IO复用模型
在上面的非阻塞IO模型中，每个进程都要去一直轮训数据是否准备好，会浪费大量的CPU效率。则可以增加一个进程来专门做这个事情，即IO复用模型。
linux提供select/poll，进程将一个或者多个fd传递给select或者poll系统调用。**比如多个请求到达，进程先传递给select或者poll系统调用，阻塞在select操作上**
select/poll顺序扫描fd是否就绪。
linux还提供epoll系统调用。**epoll基于事件驱动方式来代替顺序扫描，因此性能更高，当有fd就绪，立即回掉函数rollback。**
基于select/poll这个函数会不断轮询所负责的socket，当socket有数据到达时候，通知用户进程。**当用户进程调用select时候，进程就被block了。当有数据到达内核时候，select就会返回，这时候用户进程可以调用read操作。**
**select和poll的区别**
select中采用轮训的方式处理，数据结构类似于数组的数据结构。select的监听的数目为1024. 而epoll是维护一个队列，当队列中有活跃的socket，epoll就会取出这个socket处理。相当于实现了一个伪AIO模型。或者可以理解为wait notify
![Image](http://pbhb4py13.bkt.clouddn.com/2018-10-21-Image.png)
## 异步IO
告知内核启动某个操作，并让内核在整个操作完成后(包括数据的复制)通知进程。
信号驱动IO模型是通知何时开始一个IO操作，异步IO模型是内核通知IO操作何时完成。
当用户发起一个read操作后，立刻就去做其他的事情了。从内核角度看，当收到一个AIO后，会先立刻返回，不会阻塞用户的进程。等kernel准备好数据后，将数据copy到用户内存。完成后kernel将会给用户发送一个signal，告诉read操作完成。
![0A7D3131-DEDA-4832-AFC1-5BF94EEBAE36](http://pbhb4py13.bkt.clouddn.com/2018-10-21-0A7D3131-DEDA-4832-AFC1-5BF94EEBAE36.png)

## 多路IO复用技术
在IO编程中，服务端需要同时处理多个客户端接入请求的情况。如果每个请求都使用一个线程，**一个线程大概是1M左右，最多只能支持几w个并发数。可以使用多线程和多路IO复用技术**。

**多路IO复用技术将多个IO阻塞都绑定到一个select进程或者线程上，从而使系统在单线程的情况下能处理多个客户端的请求。**
相比于传统的多线程模型，多路IO复用的优势是系统开销小，系统不需要创建额外的线程，也不需要维护这些线程的运行，降低了系统的维护工作量，节省了系统资源。
### 多路复用IO的场景
服务端要处理多个处于监听状态或者多个连接状态的套接字。
服务器需要同时处理多种网络协议的套接字。

## IO阻塞，非阻塞，同步和异步概念
同步异步
在IO操作完成后，是用户进程主动得到的还是由kernel通知的。
阻塞非阻塞
在询问IO操作的过程是用户进程阻塞等待还是立刻得到返回结果
举几个例子吧

1. 同步阻塞
BIO socket就是一个同步阻塞的例子，当调用socket.accept后一直阻塞到由数据才返回
2. 同步非阻塞
NIO相当于是同步非阻塞。因为当发起一个io请求后，将自己绑定到select上了，等到select发现有数据后，再唤醒线程去请求数据。
3. 异步阻塞
调用blockingqueue的take()方法 take方法是从队列中获得数据，如果队列为空就阻塞。相当于第一阶段是阻塞的。但是队列中的数据不是主动去获取的，而是其他线程放入的。当有数据后通知take的线程，则是异步的。所以是异步阻塞的方法
4. 异步非阻塞
blockingqueue的poll方法，poll方法时有数据立即得到返回结果，没有数据就返回null 。所以在第一阶段是非阻塞的。数据不是主动去获取的，而是其他线程塞入的。则是异步的。AIO也是异步非阻塞的。

