<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解JVM原理 第12章 java内存模型和线程]]></title>
    <url>%2F2018%2F08%2F07%2FJVM-12%2F</url>
    <content type="text"><![CDATA[java内存模型和线程 JVM的内存模型是为了解决虚拟机实现多线程，但是多线程之间共享和竞争数据导致的问题。 硬件的效率与一致性计算机的存储设备和cpu的运算能力之间存在数量级之间的差距，所以现代计算机系统会在内存和cpu之间再插入告诉缓存cache，cache的速度和cpu的速度一致。这样的好处是每次运算都会先将数据复制到缓存中，在进行cpu计算，计算结束后再讲结果从缓存同步到内存中，这个cpu无需每次都等待缓慢的内存读写了。存在问题：缓存一致性 每个cpu都有自己的高速缓存，同时共享同一个主内存。当多个处理器处理涉及同一个内存，需要有一致性协议来保证数据一致性。同时为了使处理器内部的运算单元能被充分利用，处理器对输入的代码会进行乱序处理优化，处理器会保证结果的正确性 java内存模型 java的内存模型定义了虚拟机将变量存储到内存和从内存中取出变量这样的细节，包括实例字段，静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是私有的，不会被共享，不存在竞争问题。 Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示 注意： reference变量是局部变量中，是线程私有的，但是它的实例对象是共享的。 拷贝副本不会一次性拷贝10m的变量。volatile变量还是有工作内存的拷贝，但是它的操作顺序由特殊的规定，使它的操作就像在主内存中访问。 这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。 内存间交互操作java内存模型规定了如下8种操作来完成主内存和工作内存之间的数据交互，虚拟机保证如下8种操作是原子性的。 lock 作用主内存的变量 把一个变量标识为线程独占的状态 unlock 作用主内存的变量 把一个变量从锁定状态释放出来，该变量可以被其他线程锁定 read 作用主内存的变量 把一个变量从主内存传输到工作内存，使可以被loan动作使用 loan 作用于工作内存 把从主内存read的变量载入工作工作内存的变量副本中 use 作用于工作内存 把工作内存的变量传递给cpu，当虚拟机遇到需要读取变量的字节码会执行该指令 assign 作用于工作内存 把cpu的执行结果赋值给工作内存副本 store 作用于工作内存 把工作内存的变量传输到主内存 write 把工作内存传输的变量存到主内存的变量中。 java内存模型规定了在执行上述的8中基本操作还要满足如下规则 read 和loan 必须同时出现，即工作内存从主内存读取了对象后必须接收 不能丢弃assign操作，即工作内存的变量变化了必须同步到主内存中 没有发生assign，不能将工作内存的变量同步到主内存 lock时会清空工作内存的值，cpu需要使用这个值时必须重新loan 在unlock之前，会先将变量同步到主内存。 volatile变量的特殊规定在使用了volatile变量后，当一个线程修改了这个值，另一个线程都会立刻得知。 如果是普通的变量，只有A线程修改了值，写回主线程，B线程再读取内存的值才可以。==volatile的操作规定，v和w都是volatile变量： 线程T每次use变量v之前都要执行loan操作，loan操作和read必须同时出现。即（在工作内存中，每次使用v都会从主内存刷新得到最新的值，来保证能看见其他线程对变量v所做的改变。） 线程assign后必须执行store，store和write会同步出现，即(在工作内存中，每次修改v后必须同步回主内存中，用来保证其他线程能立即看见自己对变量v的修改) 保证volatile修饰的变量不会指令重排序优化，保证代码的执行顺序和程序的顺序相同。== volatile保证了指令不会被乱序，如果initialized没有使用volatile，那么可能由于指令重排序导致线程A的最后的initialized = true被提前执行，则线程B使用配置文件会出错。 volatile解决DCL(双重检查)问题 单例使用DCL写的懒汉式单例模式如下所示 12345678910111213141516171819202122232425public class Singleton &#123; private static Singleton instance = null; private int age; public static Singleton getInstance() &#123; if(instance == null) &#123; //1 synchonorized(Singleton.class) &#123; //2 if(instance == null) &#123; //3 instance = new Singleton(); //4 &#125; &#125; &#125; return instance; //5 &#125; public Singleton() &#123; this.age = 18; &#125; public int getAge() &#123; //6 return age; &#125;&#125; 在一般情况下该单例模式可以正常工作，但是在多线程调用该单例还是会出现并发的问题。因为可能线程会得到一个并未完全构造完成的对象。比如当A线程访问getinstance()方法，在//1出instance == null 返回true，获得锁进入同步代码块，此时线程B也访问getInstance()方法，线程B在//1处instance==null可能会返回false，但是此时instance并未完全初始化完成，线程B得到一个完全初始化的instance，线程B在调用//6时可能不能拿到age=18的结果，此时DCL的问题就出来了。问题就出在指令重排序的问题。问题出现的原因==instance = new Singleton()这一句话不是原子操作，它的操作可以分为如下三个部分： 分配内存空间 实例化对象instance 把instance引用指向的已分配的内存空间，此时instance有了内存地址，不再是null了== java允许对指令进行重排序，那么以上3步的执行顺序就可能是1-3-2，在这种情况下如果线程A执行完1-3后被阻塞了，此时线程B进来获得了instance的引用，因此此时instance不为空，直接到//1就返回了获得了没有实例完全的对象。 使用volatile可以避免这个问题，因为volatile的对象保证不会被指令重拍序，在操作volatile对象之前的代码一定是执行完毕并且可见，在变量操作之后的代码一定是还没有被执行的。所以当instance被定义成volatile时，保证创建的顺序一定是1-2-3，instance一定是null或者完全初始化完成的对象。其实可以创建成一个static类并获取对象，因为虚拟机会自动保证静态变量的并发。 12345678910111213141516171819202122232425public class Singleton &#123; private volatile static Singleton instance = null; private int age; public static Singleton getInstance() &#123; if(instance == null) &#123; //1 synchonorized(Singleton.class) &#123; //2 if(instance == null) &#123; //3 instance = new Singleton(); //4 &#125; &#125; &#125; return instance; //5 &#125; public Singleton() &#123; this.age = 18; &#125; public int getAge() &#123; //6 return age; &#125;&#125; volatile变量在并发下不安全volatile变量规定对所有线程都是立即可见的，对volatile的所有写操作都是可以立刻反应到其他的线程中。虽然volatile变量不存在一致性问题，但是java运算操作不是原子性的，所以volatile变量的运算不是安全的。还volatile变量禁止指令重排序。比如自加操作。race++这个过程需要有多个步骤，将race的值取到栈顶，这个过程是正确的，但是接下来的自加操作中如果有其他的线程往主内存写数据就会使数据写回出错。写回去的值可能会比理论值小。什么情况下可以使用volatile变量 运算结果不依赖当前值，或者确保只能一个线程可以修改变量的值2。 变量不需要其他的状态变量共同参与不变约束。 ##原子性，可见性，有序性java的内存模型都是围绕着在并发过程中如何处理原子性，可见性，有序性三个特征建立的 ==原子性== &nbsp;&nbsp;&nbsp;&nbsp;java内存模型直接保证8个基本操作是原子性的，如果要在大范围内保证原子性，必须使用monitorenter和monitorexit来隐式使用，这个反映到java代码就是同步代码块synchonorized关键字，即synchonorized的代码是原子性的。 ==可见性== &nbsp;&nbsp;&nbsp;&nbsp;一个线程修改了变量的值，其他的线程能立刻得到这个新的值。如volatile变量，除了这个变量，synchronized和final也可以完成可见性。final字段初始化后就能立刻被其他线程访问。 ==有序性== &nbsp;&nbsp;&nbsp;&nbsp;线程内表现为串行的操作，在其他的线程看来是无序的。包括指令重排序和主内存同步延迟现象。 对于可见性，violatile保证可见性，synchonorized和final也能保证可见性。synchonorized同步快的可见性是“对一个对象执行unlock前必须将变量同步到主内存(执行store，write)中”保证，我理解同步块是保证了锁定的对象的可见性。final关键字的可见性是被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”引用传递出去，那么其他线程就能得到正确的值。==this指针逃逸是一件危险的事情，其他线程可能访问到初始化了一半的对象。==对于有序性，violatile和synchonorized都能保证有序性，==violatile是防止指令重排序，synchonorized是由一个变量在同一时刻只能一个线程对其lock操作的这个规则获得的==。则决定了同一个锁的两个同步快只能串行的进入。 ###先行发生原则虚拟机可以对不满足先行原则的指令进行任意顺序的重排序。满足先行发生原则的规则如下： 程序次序原则&nbsp;&nbsp;&nbsp;&nbsp;在一个线程内，代码按照顺序执行 管程锁定规则&nbsp;&nbsp;&nbsp;&nbsp;对同一个锁，unlock操作时间上先行发生于后面的lock操作 volatile变量规则&nbsp;&nbsp;&nbsp;&nbsp;对一个volatile变量的写操作先于度操作 线程启动原则&nbsp;&nbsp;&nbsp;&nbsp; Thread的start()先于该线程的任何操作 线程终止原则&nbsp;&nbsp;&nbsp;&nbsp;Thread的所有操作都先于线程的终止检测。可以通过Thread.join()和Thread.isAlive()的返回值检测线程是否已终止 线程终端规则 线程的interrupt()方法先于中断线程检测到中断事件的发生，即可以使用interrupted()方法检测到线程是否被中断了。 对象终结原则 对象构造函数执行完毕先于finilized()方法 传递性 A先于B，B先于C。保证A先于C java和线程线程是比进程轻量级的调度单位。各个线程可以共享进程的资源(内存地址，文件I/O)等，又可以独立调度。==线程是CPU调度的基本单位==。实现线程一般有3种实现方式，内核线程实现，用户线程实现，用户线程加轻量级进程混合实现。 内核线程&nbsp;&nbsp;&nbsp;&nbsp;内核线程(Kernal-Level Thread KLT) 由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过调度器对线程进行调度，支持多线程的内核叫做多线程内核。程序一般会使用内核线程的一种高级接口–轻量级进程(Light Weight Process LWP)轻量级进程就是通常意义的线程，每个轻量级进程都是由一个内核线程支持，因此先有内核线程，才能有轻量级进程。之间的数量关系为1：1。==内核线程耗时好资源，无法创建大规模的内核线程，并发数量低。== 用户线程&nbsp;&nbsp;&nbsp;&nbsp;系统内核感知不到用户线程的存在。线程的创建，同步，销毁，调度都由用户态完成。优点：快速低耗，可以支持更大规模的线程数量。缺点：很难实现线程的调度。==因为CPU只会调度内核线程，用户线程没有内核线程的支持无法处理切换和调度。这个部分都需要用户自己去实现，比如当一个线程死循环不放弃CPU资源，其他线程将用户无法得到执行。== 用户线程加上轻量级进程混合实现&nbsp;&nbsp;&nbsp;&nbsp;该方法使用户线程的创建，切换，调度方便，支持大规模的用户线程并发，并且操作系统提供了轻量级进程作为用户线程和内核线程的桥梁，使用内核的调度功能，即用轻量级进程来调度用户线程，用户线程和轻量级进程的数量比例为N:M。 java线程调度 协同式线程调度 &nbsp;&nbsp;&nbsp;&nbsp;线程的执行时间由线程控制，线程完成工作后通知系统切换到另一个线程。优点:实现简单，不存在线程同步的问题。缺点：一个进程不退出cpu时间就会爆炸 抢占式线程调度&nbsp;&nbsp;&nbsp;&nbsp;java使用该方法来调度。线程的执行时间由系统来决定。 ##java线程的6种状态 新建（New）:创建后尚未启动 运行（Runable）：包括running和ready两个状态 状态可能是正在运行或者等待时间片 无限期等待（Waiting）：线程无法获得CPU时间片，必须等待其他线程显示唤醒。 没有设置时间的Object.wait()，Thread.join()方法,LockSupport.park() 限期等待(Timed Waiting) 线程不会被分配CPU时间片也无需被其他线程显示唤醒，到时间自动唤醒。Thread.sleep()方法，设置等待时间的Object.wait()，Thread.join()方法，LockSupport.parkNanos()方法，LockSupport.parkUntil()方法 阻塞(Blocked) 阻塞状态和等待状态的区别是阻塞是等待获取一个排他锁，等待状态是等待唤醒动作的发生，这个过程在线程等待进入同步区域的时候，线程会进入这个状态 结束(Terminated)：线程被终止]]></content>
      <categories>
        <category>JVM虚拟机原理</category>
      </categories>
      <tags>
        <tag>JVM原理</tag>
        <tag>java内存模型</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机 第6章 类文件结构]]></title>
    <url>%2F2018%2F07%2F27%2FJVM-6%2F</url>
    <content type="text"><![CDATA[深入理解Java虚拟机 第六章 类文件结构class类文件的结构 123456789101112131415161718ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; //常量池，字面量和符号引用 u2 access_flags; //访问标志 u2 this_class; //全限定名 u2 super_class; //父类全限定名 u2 interfaces_count; //接口数量 u2 interfaces[interfaces_count]; //接口的全限定名 u2 fields_count; field_info fields[fields_count]; //类或接口的字段 u2 methods_count; method_info methods[methods_count]; //方法表 u2 attributes_count; attribute_info attributes[attributes_count]; //属性表，code，exception等&#125; class文件是以8字节为基础的二进制流，各个数据都是按一定的顺序排列，如果需要占用8字节以上的空间数据，按照高位在前分割存储 class文件的存储结构只有2种，无符号数和表 无符号数 基本的数据类型，u1,u2,u4,u8类表示1，2，4，8个字节的无符号数，可以描述数字，索引引用，数字量，按UTF-8编码的字符串。 表 是由多个无符号数组成的复合数据类型，所有表以_info结尾，整个class就是一张表 6.2 魔数Class文件的头4个字节，作用：确定这个文件是否为一个能被虚拟机接受的Class文件。值为：0xCAFEBABE(咖啡宝宝) 6.3 版本号紧接着魔数的4个字节。第5，6字节是次版本号，第7，8字节是主版本号 6.4 常量池常量池可以理解为class文件的资源仓库。主要存放了两大类常量：字面量和符号引用。 字面量 string类型的字面量和final类型常量符号引用 包括3中类常量 1.类和接口的全限定名 2.字段的名称和描述符 3.方法的名称和描述符 java在虚拟机加载class文件时才会动态链接，class文件中不会保存各个方法，字段的最终布局，这些字段，方法的符号引用需要在运行时的转换才能得到真正的内存入口。在虚拟机运行时会从常量池中得到对应的符号引用，在类创建时解析。常量池的14中常量结构 比如CONSTANT_CLASS_info,代表类或接口的符号引用，表中的name_index指向CONSTANT_UTF8_info类型的数据，这个存放着我们类的全限定名。 6.5访问标志常量池结束后的两个字节是表示访问标志，用于识别类或者接口的访问信息，比如是类还是接口，访问类型，是否final等等。 6.6类索引，父类索引，接口索引集合class文件由这三个数据来确定类的继承关系。类索引(this_class)和父类索引(super_class)是u2类型的数据，接口索引集合是u2类型的数据集合。 类索引可以确定类的全限定名，父类索引可以确定类的父类全限定名，除了Object类，其他类都有1个父类。接口索引集合按照implements顺序从左到右排列在集合索引中 6.7字段表集合字段表描述类或者接口中申明的变量。字段包括类变量和实例变量，不包括方法内部的局部变量。字段表的格式如下所示，access_flags是字段的访问标志，public，可变性final，并发性violatile等等。其中name_index和descriptor_index是对常量池的引用，代表字段的简单名称和方法的描述符。 全限定名，简单名称，描述符的区别 全限定名是org/fenixsoft/clazz/TestClass是类的全限定名 简单名称 指没有类型和参数修饰符的方法或者字段名称 inc()方法和m字段的简单名称为inc 和m 字段和方法的描述符的解释如下 字段的描述符如下所示对于数组类型，每一维度用[表示，比如java.lang.string[][]的描述符为[[Ljava/lang/String, int[]的描述符为[I描述符描述方法时按照先参数列表再返回值，比如void inc() 表示为()V 方法java.lang.String toString() 表示为 （）Ljava/lang/String ， 方法int indexOf(char[]source, int sourceOffset)可以表示为([CI)I。 6.8方法表集合方法表和字段表类似，结构也是访问标志，名称索引，描述符索引，属性表集合等。 方法的定义在可以通过方法的访问标志，名称索引，描述符索引表达清楚，方法内部的代码是经过java的编译器编译成字节码后存放在方法属性集合中的名为“code”的属性中 在java语言中，重载(override)一个方法，除了和原方法的简单名称一样，还需要和原方法有一个不同的特征签名,特征签名是一个方法中不同参数在常量池中的字段符号引用的合集，所以返回值不会包含在特征签名中，所以无法通过返回值来重载方法 6.9 属性表 code属性java代码经过javac编译后会变成字节码指令存储在code属性中。code属性存放在方法表的属性中，但是不是所有的方法表中都存在code属性，比如接口和抽象类的方法就不存在code属性 max_stack是操作数栈深度的最大值max_locals是局部变量所需的空间 max_locals的单位值slot，slot是虚拟机为局部变量分配内存的最小单位，除了double和long两者是需要2个slot存放，其他的都是1个slot来存放方法参数包括this，异常处理的参数，即try catch中定义的异常，方法体中的局部变量都是用slot来存放。slot可以被复用，只要保证正确性。 code_length和code是存储的字节码exception是方法中可能抛出的受查异常，也就是throws的异常ConstantValue属性是为静态变量赋值 异常表编译器是采用异常表而不是简单的跳转命令来实现java的异常和finally处理机制看出0-9行是正常返回，10-20是exception型的异常返回，21-25是非exception得异常返回。3中路径都有finally中的代码，finally的代码是会嵌套在3种路径的代码之后在return之前。结果是没有异常，返回1，出现exception异常，返回是2，出现exception以外的异常，方法没有返回值。 字节码指令简介 加载和存储指令加载和存储指令将数据在栈帧的局部变量表和操作数栈之间传输 运算指令将连个操作数栈的值进行运算，再将结果存回操作数栈顶 类型转换转换类型，虚拟机直接支持从小范围类型向大范围类型的安全转换，大数到小数就要使用转换指令 对象创建和访问指令new，newarray，访问类字段 getstatic 访问非类字段 getfield 方法调用指令 invokevirtual 调用方法的虚方法，根据方法的实际类型进行分派invokeinterface 调用接口的方法，搜索实现接口方法的实例对象并找出最合适的方法调用invokespecial 调用特殊的方法，比如实力初始化方法和私有方法和父类方法invokespecial 类方法staticinvokedynamic 运行时动态解析出引用的方法。 同步指令java虚拟机支持方法级的同步和方法内部指令的同步，两种的同步结构都是使用管程(Monitor)来支持。比如synchronize的语句实现是monitorenter和monitorexit来实现，执行的线程必须先成功持有管程，然后才能执行方法，方法最后成功或者非正常完成都会释放管程。同步方法在执行时跑出异常，在内部无法处理异常，同步方法持有的管程在异常被抛到同步方法之外时也被自动释放。]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2F2018%2F07%2F12%2FJVM%2F</url>
    <content type="text"><![CDATA[虚拟机类加载机制 虚拟机类加载机制虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。Java语言里，类型的加载和连接过程是在程序运行期间完成的。 类加载的时机 类加载的生命周期： 加载 验证 准备 解析 初始化 使用 卸载加载，验证，准备，初始化，卸载的顺序是确定的，为了支持java的动态绑定，解析过程可以在初始化之后调用，即动态绑定或者称为晚期绑定4种必须对类进行“初始化”的情况 new，getstatic，putstatic，invokestatic这4个字节码，对类没有初始化必须先对类进行初始化，即使用new生成对象，读取或者设置类的static变量，final修饰的static变量在编译器把结果放在常量池了除外，调用类的static方法 使用java.lang.reflect包的方法对类进行反射调用 初始化一个类时，其父类未初始化，先触发父类的初始化过程 main方法包含的类要先初始化 被动引用: 通过子类调用父类的静态字段不会导致子类的初始化(对于静态字段，只有直接定义这个字段的类才会被初始化) 通过数组定义应用类 classA[] array = new classA[10]；不会初始化classA，只有该数组去访问classA对象的成员时才会加载类 常量会在编译期间存入调用类的常量池 final字段 123456789101112131415161718192021222324252627//对于static字段，只有直接定义这个字段的类会被加载class A ｛ public static int i = 2;｝class B extends A&#123; public static void main(String[] args) &#123; System.out.println(B.i); &#125; &#125;//数组不会触发类的加载,只有访问i才会加载class A ｛ public static int i = 2;｝class B &#123; public static void main(String[] args) &#123; A[] a = new A[10]; &#125;&#125;//final字段是不会触发A类的加载，会触发B的加载，因为i会被转化成B对自身常量池的引用class A ｛ public static final int i = 2;｝class B &#123; public static void main(String[] args) &#123; System.out.println(A.i); &#125; &#125; java方法的绑定java方法的调用需要先将方法和调用方法的类绑定起来，绑定分为静态绑定和动态绑定： 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。 加载加载是“类加载”的一个过程。加载过程主要完成3件事情： 通过类的全限定名来获取定义类的二进制字节流 将字节流表示的静态存储结果转化成方法区中的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据结构的访问入口 类加载器对任何一个类，需要由它的类加载器和本身的class文件来确定在虚拟机中的唯一性。即一个class文件用两个类加载器加载出来的类是不想等的。equals()，isInstance 等方法的返回结果不同,使用instanceof的返回结果也不同。 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(".") + 1)+ ".class"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) return super.loadClass(name); byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myLoader.loadClass("Main").newInstance(); System.out.println(obj.getClass()); //class Main System.out.println(obj instanceof Main); //false Main main = Main.class.newInstance(); System.out.println(main.getClass().isInstance(obj)); //false &#125;&#125; 上述的两个对象一个是使用应用程序类加载器加载的，一个是自定义的类加载器加载，虽然来自同一个clas文件，但是属于两个不同的类。 双亲委派模型 类加载器的层次图如图所示 ,称为类加载器的双亲委派模型, 双亲委派模型要求顶层的启动类加载器外，其余的类均要有自己的父类加载器，而类加载器不是以继承关系实现，而是使用组合的方式来加载父加载器。 123456789101112131415161718192021222324252627@CallerSensitivepublic ClassLoader getClassLoader() &#123; ClassLoader cl = getClassLoader0(); //获取自身classloader if (cl == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; // caller can be null if the VM is requesting it ClassLoader ccl = getClassLoader(caller); //isAncestor方法将类加载器派给了引导类加载器 if(cc1 != null &amp;&amp; cc1 != c1 &amp;&amp; !c1.iaAncestor(cc1)) &#123; sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; &#125; return cl;&#125;//判断c1是不是this的父类加载器 同时c1的引用也会改变，变成c1的parentboolean isAncestor(ClassLoader cl) &#123; ClassLoader acl = this; do &#123; acl = acl.parent; if (cl == acl) &#123; return true; &#125; &#125; while (acl != null); return false;&#125; 启动类加载器 BootStrap ClassLoader用c++编写，该加载器加载java_home/lib的库文件，将库类加载器到虚拟机内存中。启动类加载器无法被java程序使用 扩展类加载器 extension classLoader 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader， 该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序由这三种类加载器配合加载，我们也可以自定义类加载器。因为JVM自带的类加载器只是从本地的文件系统中加载标准的java class文件，使用自己编写的classLoader，可以 执行非致信代码前，自动检验数字签名 动态创建自定义的类 从特定的场所取得java class，比如数据库和网络IO中 双亲委派模型的工作流程一个类加载器收到类加载的请求，不会自己先尝试加载这个类，而是将请求委托类父加载器区完成，所有的类加载器都会传递到顶层的启动类加载器区加载，当父加载器无法找到需要的类时，自加载器才会尝试自己去加载这个类。使用该模型去组织类加载器的好处是java类带有层次性，比如类java.lang.Object存放在JDK\jre\lib下的rt.jar，即(java_home\lib)路径下，最终都会使用启动类加载器区加载，保证了Object类在各个类及载器中都是同一个类。 类加载的验证阶段验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。在idea中的报错的东西都是在这个阶段检查的虚拟机规范：如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个java.lang.VerifyError异常或其子类异常 类加载的准备阶段 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段类变量是static变量，不包括实例变量，这些变量所使用的内存都在方法区中分配。初始值一般指零值 public static int value = 123 在准备阶段后value的值为0，而不是123，在类的初始化阶段才会赋值为123。 public static final int value = 123 final类型的变量在准备阶段就会初始化成指定的值，存在运行时常量池中。 注意点： 对于基本数据类型，static变量和成员变量没有显示赋值会使用默认值，但是局部变量在使用前必须显示赋值，否则编译不通过 static final 类型的变量在申明时必须显示赋值，否则编译不通过。final类型的变量在申明时赋值，或者类初始化后赋值，总之final类型的变量必须显示赋值。static类型的变量在准备阶段会赋零值 对于reference，数组引用，对象引用，没有显示赋值而直接使用，系统会赋null 数组中的元素没有赋值，会使用零值。 1234567891011public class main1 &#123; public static int i; public final int ii; //final可以在构造函数内初始化 public main1() &#123; ii = 1; &#125; public static final int iii; //必须显示初始化，因为static会在准备阶段赋零值 static &#123; iii = 1; //这里赋值也可以，因为都是在准备阶段执行 &#125;&#125; 类加载的解析阶段解析阶段可能在初始化之后，阶段不固定。解析阶段就是将加载的类中常量池里的符号引用转化成直接引用的过程。 符号引用符号引用是用符号来表示引用的对象，只要符号可以无歧义的定位到目标对象即可。目标对象可以在内存中还不存在。 直接引用直接引用时可以直接指向目标中的指针，相对偏移量或者能间接定位到目标的句柄。直接引用的目标在内存中必须存在。A.f1(),符号引用指的是方法区中的偏移量，直接引用指的是直接指向类的方法的入口地址，f1()具体的方法地址 类的解析当前的类为D，将一个符号引用N解析为类或接口C的直接引用，1 C N = new D() 如果C不是数组类型，那么会将N的权限定名给D，用D的类加载器去加载。2 C[] N = new D[100] C时数组类型，不会去启动D的类加载器去加载，但是虚拟机会生成一个表示这个数组的对象。 字段解析对字段表中的class_index的索引中的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或者接口的符号引用。比如在方法里调用了C.a 将字段所属的类定义为C如果C本身存在字段a，直接返回a的直接引用。如果C实现了借口，按照继承关系从下往上递归搜索各个接口和父接口，找到字段a的直接引用。如果C不是Object，则从下往上递归搜索父类中的字段，直到找到a都没有找到，抛出异常 类方法解析 C.a()解析先在类方法表中的索引的方法所属的类或者接口的符号引用。在C中找到a的直接引用。否则在C的父类中找到和这个方法的直接引用，查找结束。否则在C的接口中找到这个方法的引用，如果存在，说明C是抽象类，则查找结束，抛出异常。 接口方法解析 c.a() c是一个接口则先查c自身的接口，没有就查父接口 ，直到查到a的直接引用。类加载的初始化阶段类初始化阶段是类加载过程的最后一步，在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。在初始化阶段实际是执行类构造器的方法&lt;clinit&gt;()方法， &lt;clinit&gt;()会由编译器自动收集类中的类变量的赋值动作和静态语句块(static{}块)语句合并，并且顺序由原文件的顺序决定。静态语句块中只能给访问到静态语句块之前的变量，在它之后的变量可以访问，但是不能赋值 1234567public class Test &#123; static &#123; i = 0; //给变量赋值可以正常编译通过 System.out.print(i); //编译器会提示“非法向前引用” &#125; static int i = 1;&#125; &lt;clinit&gt;()和类的实例构造器不同&lt;init&gt;()，它不需要显示调用父类的构造器，虚拟机会保证在子类初始化之前父类已经初始化完毕。因此虚拟机中第一个被执行&lt;init&gt;()一定是java.lang.Object类。 父类的static代码块一定会优先于子类的static代码块先执行。 &lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。 接口中不能使用静态语句块，但仍然有变量初始化的操作，因此接口与类一样都会生成&lt;clinit&gt;()方法，但与类不同的是，执行接口的初始化方法之前，不需要先执行父接口的初始化方法。只有当父接口中定义的变量使用时，才会执行父接口的初始化方法。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待，直到活动线程执行类初始化方法完毕。 很简单，下面代码执行的结果为2，而不是1 12345678910111213static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125; &#125;static class Sub extends Parent &#123; public static int B = A; &#125;public static void main(String[] args) &#123; System.out.println(Sub.B); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[postName]]></title>
    <url>%2F2018%2F07%2F04%2FpostName%2F</url>
    <content type="text"><![CDATA[testasdasdasdasdasdasdasd]]></content>
      <categories>
        <category>学习</category>
        <category>post</category>
      </categories>
      <tags>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
