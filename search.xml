<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[threadLocal原理解析]]></title>
    <url>%2F2018%2F08%2F17%2FthreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocalThreadLocal的用法 在工作中使用到了ThreadLocal变量，但是对其原理不是非常的清楚，只是知道可以保存一个共享变量到本地线程的副本，线程之间不会竞争访问该变量。具体到在原理层面上如何去实现，还有ThreadLocal引发的内存泄漏问题都不是非常清楚。这篇博客将会讲讲我对源码的了解。 ThreadLocalLocal的用法如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ThreadlocalTest &#123; //创建一个ThreadLocal对象，设置初始值为3 private ThreadLocal&lt;Integer&gt; tlA = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return 3; &#125; &#125;; private ThreadLocal&lt;Integer&gt; tlB = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return 3; &#125; &#125;; //信号量 每次允许一个线程进入 Semaphore semaphore = new Semaphore(1); public class Worker implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int valA = tlA.get(); System.out.println(Thread.currentThread().getName() + "tlA 的初始值 = " + valA); valA = new Random().nextInt(); tlA.set(valA); System.out.println(Thread.currentThread().getName() + "tlA 的新值 = " + valA); int valB = tlB.get(); System.out.println(Thread.currentThread().getName() +"tlB 的初始值 = "+ valB); valB = new Random().nextInt(); tlA.set(valB); System.out.println(Thread.currentThread().getName() +"tlB 的新值 = "+ valB); semaphore.release(); &#125; &#125; /*创建三个线程，每个线程都会对ThreadLocal对象tlA进行操作*/ public static void main(String[] args)&#123; ExecutorService es = Executors.newFixedThreadPool(3); ThreadlocalTest tld = new ThreadlocalTest(); es.execute(tld.new Worker()); es.execute(tld.new Worker()); es.execute(tld.new Worker()); es.shutdown(); &#125;&#125; 运行结果如下所示： 123456789101112pool-1-thread-1tlA 的初始值 = 3pool-1-thread-1tlA 的新值 = -1506777037pool-1-thread-1tlB 的初始值 = 3pool-1-thread-1tlB 的新值 = 906618508pool-1-thread-3tlA 的初始值 = 3pool-1-thread-3tlA 的新值 = 1707618403pool-1-thread-3tlB 的初始值 = 3pool-1-thread-3tlB 的新值 = -1088499016pool-1-thread-2tlA 的初始值 = 3pool-1-thread-2tlA 的新值 = -601273490pool-1-thread-2tlB 的初始值 = 3pool-1-thread-2tlB 的新值 = 1428640209 从运行结果来看，每次调用ThreadLocal对象的get方法都得到了初始值3，让3个线程按照顺序执行，从结果看pool-1-thread-1线程结束后设置的tlA的新值对pool-1-thread-3没有影响，线程3还是得到的是ThreadLocal对象的初始值3。相当于把该ThreadLocal对象当成是本地变量一样，但是该变量其实是一个共享全局变量。 骚一点，接着对上述的代码做一些简单的改变。将main函数改变线程池的容量大小为1 123456789/*创建三个线程，每个线程都会对ThreadLocal对象tlA进行操作*/ public static void main(String[] args)&#123; ExecutorService es = Executors.newFixedThreadPool(1); ThreadlocalTest tld = new ThreadlocalTest(); es.execute(tld.new Worker()); es.execute(tld.new Worker()); es.execute(tld.new Worker()); es.shutdown(); &#125; 运行结果如下 123456789101112pool-1-thread-1tlA 的初始值 = 3pool-1-thread-1tlA 的新值 = -1998579477pool-1-thread-1tlB 的初始值 = 3pool-1-thread-1tlB 的新值 = 1571049844pool-1-thread-1tlA 的初始值 = 1571049844pool-1-thread-1tlA 的新值 = -1394637541pool-1-thread-1tlB 的初始值 = 3pool-1-thread-1tlB 的新值 = 618157570pool-1-thread-1tlA 的初始值 = 618157570pool-1-thread-1tlA 的新值 = -732125710pool-1-thread-1tlB 的初始值 = 3pool-1-thread-1tlB 的新值 = 2035779705 从运行结果中看出tlA的值被多个线程共享了，其实是因为线程池用的都是同一个线程，所以访问的是共享的变量。 接着我们看其实现原理 ThreadLocal的源码解析在Thread类中定义了一个threadLocals,默认是null。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; 在第一次调用ThreadLocal的get方法时，会为Thread线程创建一个ThreadLocalMap对象，这个是一个散列表，key是ThreadLocal对象，set方法中的值作为value，第一次调用get时，以initValue()方法返回的结果作为值。 123456789101112131415161718192021222324public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; //设置初始值private T setInitialValue() &#123; T value = initialValue(); //这个方法可以被重写，设置自己的初始值 Thread t = Thread.currentThread(); ThreadLocalMap map = t.threadLocals; if (map != null) map.set(this, value); else t.threadLocals = new ThreadLocalMap(this, firstValue); return value; &#125; 图片出处 https://www.cnblogs.com/nullzx/p/7553538.html ThreadLocalMap对象ThreadLocalMap是ThreadLocal对象内部的一个静态类，内部是维护了一个Entry的散列表，代码如下 123456789101112131415161718192021222324252627282930313233static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k);//调用weakReference的构造函数 value = v; &#125; &#125; private Entry[] table; ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; &#125; 每个线程都有一个ThreadLocalMap对象，key为ThreadLocal&lt;?&gt;对象，value为Object。可以在方法中定义多个threadLocal对象，但是一般都是讲ThreadLocal对象定义为static类型或者外部类中。相同的key在不同的Thread中的值是不同的。每个线程都操作各自的ThreadLocalmap对象。 Entry继承了WeakReference，且设置key为弱引用，WeakReference是在gc时一定会被回收的对象，softReference是在gc后内存不足才会再gc一遍回收软引用指向的对象。.jpg) ##ThreadLocal造成的内存泄露 首先，我们要明确Entry是一个强引用，Entry的key即threadLocal是一个弱引用，当这个对象只有没弱引用持有时，一定是被gc掉的。 考虑一种情况，在一个方法内申明一个ThreadLocal对象，并设置了value值。当方法运行结束时，该threadLocal对象将没有被栈的变量指向，只有Entry的一个弱引用。那么在gc时，会出现上图中所示的key为null，value存在的情况，而且该value将无法被访问。则就出现了内存泄漏。 在get方法中的getEntry方法中存在如下的一段代码。当key为null时，会调用expungeStaleEntry()方法去遍历删除所有的key为null的Entry方法。在调用get方法，set方法，remove方法，在key为null时会删除所有的为null的key 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); //其实就是i++ e = tab[i]; &#125; return null;&#125;//遍历删除所有key为null的Entryprivate int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; //重新hash int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 上述的方法并不能保证解决内存泄漏的问题，因为在调用get方法是不一定能获得key为null的对象。当线程结束时，ThreadLocalMap对象会被回收，那么完美。但是使用线程池时，如果ThreadLocal对象被回收，而线程是回收待使用，则value会一直存在堆中无法被访问。内存就会被一直泄漏。使用线程池时使用不当还会发生bug。当定义一个static的ThreadLocal对象，使用线程池，在线程中set了一个ThreadLocal对象。那么下一个线程会得到上一个线程的value，造成bug。就像最开始的代码中的运行结果。所以在线程结束时，手动remove掉该ThreadLocal。 ok]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机 第13章 线程安全和锁优化]]></title>
    <url>%2F2018%2F08%2F14%2FJVM-13%2F</url>
    <content type="text"><![CDATA[线程安全与锁优化线程安全的定义: 当多个线程访问一个对象时，如果不用考虑这些线程在运行时的调度和交替运行，也不需要执行额外的同步，或者在调用方法时进行其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。 线程安全的5种数据不可变一个final的对象被正确的构造出来后(在构造过程中没有发生this指针溢出)，那么这个对象永远不会处于多个线程中不一致的情况，即是线程安全的。如果共享数据是基本数据类型，只要使用final关键字修饰就可以了。如果是对象，则保证对象的行为对状态不会有影响。比如java.lang.String类。调用他的substring()等方法都是返回一个新构造的对象，线程安全的。对象行为不影响自己状态可以把对象中带有状态的变量都申明为final，这样在构造函数结束后就是不可变的。比如java.lang.Integer的构造函数。final类型的变量由JVM保证读取变量的值必须在变量赋值之后。 1234567891011private final int value; /** * Constructs a newly allocated &#123;@code Integer&#125; object that * represents the specified &#123;@code int&#125; value. * * @param value the value to be represented by the * &#123;@code Integer&#125; object. */ public Integer(int value) &#123; this.value = value; 绝对线程安全java.util.Vector是一个线程安全的容器，因为它的方法都加上了synchronized关键字，虽然效率比较低，但是是线程安全的。 1234567891011121314151617181920212223242526272829303132private static Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;); Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125;); removeThread.start(); printThread.start(); // 不要同时产生过多的线程，否则会导致操作系统假死 while (Thread.activeCount() &gt; 20); &#125; 上述的操作会导致数据越界，因为组合操作不是线程安全的，需要对Vector对象进行加锁操作。 1234567891011121314151617181920Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125; &#125;); Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125; 相对线程安全大部分的容器都是相对线程安全的， Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。 线程安全的实现方法互斥同步多个线程并发访问时保证共享书只会被一个线程使用，实现互斥同步的手段有临界区、互斥量、信号量。在java中使用synchronized关键字，被编译后会在同步块的前后分别加入monitorenter和monitorexit两个字节码指令，这两个字节码都需要一个reference类型的参数来指明锁定的对象。synchronized明确指明了锁定的对象，那么就是这个对象，如果没有指明，那么就要看synchronized修饰的是实例方法还是类方法，分别取对应的对象实例和class对象作为锁对象。根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，相应的，在执行 monitorexit 指令时将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。使用synchronized同步代码块有2点需要注意： synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。采用计数器的方式+1即可。 java线程是通过操作系统的内核线程或者称为轻量级线程来实现阻塞和唤醒。则每次阻塞线程，需要操作系统先将用户态切换到内核态，状态转换需要耗费很多的时间，可能比代码执行的时间还长。因此synchronized操作是重量级锁，虚拟机本身对synchronized进行了优化，比如操作系统在阻塞线程前进行一段时间的自旋等待过程，避免频繁切换状态 除了synchonorized，还可以使用java.util.concurrent包的ReentrantLock来实现同步。用法上也可以实现重入锁，ReentrantLock加入了许多高级功能，等待可中断、实现公平锁、锁绑定多个条件 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。 非阻塞同步互斥同步最主要的问题是进行线程切换和唤醒所带来的性能问题，因为要从用户态切换到核心态，使用轻量级线程来调度用户线程的。并且互斥同步属于悲观锁，无论数据是否存在竞争，都会进行加锁的操作。采用乐观的并发策略的实现可以不用将线程挂起，这种同步操作称为非阻塞同步。java中一般使用CAS指令完成乐观锁的操作，该指令有3个操作元素，分别是内存位置V、旧的预期值A和新值B。CAS 指令执行时，当且仅当V符合旧值预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。 12345678public final int incrementAndGet() &#123; for (;;) &#123; int current = get(); //使用volatile保证可见性 int next = current + 1; if (compareAndSet(current, next)) return next; &#125; &#125; incrementAndGet()方法在一个无限循环中，不断尝试将一个比当前值大 1 的新值赋给自己(内部维护了volatile的值)。如果失败了，那说明在执行 “获取-设置” 操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止。 但是CAS存在漏洞，即ABA问题，初始值为A，在准备赋值时检查仍然为A，但是其中可能先变成B。即ABA问题。 ThreadLocal无同步方案如果一个变量希望只在一个线程中使用，那么可以把这个变量的可见性范围限制在一个线程之中。比如web服务端中，一个请求对应一个服务器线程的处理方式可以使用线程本地储存完成。如果一个变量会被多个线程访问，可以使用volatile变量，该变量的原理前面已经讲过了。如果一个变量需要被一个线程独享，那么可以使用ThreadLocal类来实现线程本地存储。这个类的原理另外开一篇博客说明。 锁优化代码层减少锁的持有时间(锁粗化)，减少锁的粒度(concurrentHashMap,分段锁机制),锁分离(读写锁) JVM层面 锁消除 如果运行时不会出现竞争，直接将锁消除。 偏向锁 为了避免一个线程对访问的对象重复加锁和解锁，浪费资源。JVM将对象设置为可偏向的，这个是在对象的对象头的Mark Word里面设置的。默认将Mark Word的ThreadId设置为0，当第一个线程访问这个对象时，通过CAS操作将ThreadID设置为线程的ID，线程运行同步代码块。执行完不释放偏向锁，线程下次访问的时候不需要加锁和解锁。如果另外的线程竞争这个锁时，当前线程的锁升级为轻量级锁，另外的线程进行自选等待，如果自旋结束前，上一个线程释放了轻量级锁，该线程获得轻量级锁，如果自旋结束后锁没有被释放，那么轻量级锁会升级为重量级锁，自旋结束的线程进入阻塞状态。 自旋锁 当一个物理机器存在一个以上的处理器能让两个线程同时进行，那么可以让后面请求锁的线程先忙循环(自旋)，但是不放弃处理器的执行时间，称为自旋锁。 自旋锁虽然避免了线程切换的开销，但是也是会占用处理器的执行时间，如果锁占用的时间很短，自旋等待的效果会很好。否则会性能浪费。引入了自适应的自旋锁，默认是10次的自旋时间，如果锁在同一个对象，并且上一次自旋成功了，那么这次的自旋时间会加长，否则会缩短。 锁消除 对于如下的代码，因为String是final类型的，所以一定是线程安全的。 123public static String concatString(String s1, String s2, String s3) &#123; return s1 + s2 + s3;&#125; 但是在代码编译后会变成如下的样子 12345678public static String concatString(String s1, String s2, String s3) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; StringBuffer的append()方式使用了synchonorized同步代码块。虚拟机观察了变量sb后，发现它无法逃逸到concatString()方法之外，其他线程无法访问到，则这里虽然有锁，但是会被消除，代码编译后不会添加monitorenter和moniterexit。 锁的状态和转化锁的状态主要有 无锁状态、偏向锁状态、轻量级锁状态，重量级锁状态状态转化 当JVM设置偏向状态时，则默认对象处于偏向锁状态 (CAS操作) 当两个线程竞争锁时，获得偏向锁的线程升级为轻量级锁，如果不再活动，转化成无锁状态，如果再活动，升级为重量级锁，然后解锁，进入无锁状态。轻量级锁能提升程序的同步性能的依据是绝大多数的锁，在整个同步周期内是不存在竞争的。因为没有竞争，轻量级锁使用CAS操作避免了互斥量的开销，如果存在锁竞争，除了互斥量的开销，还要发生CAS操作，因此在有竞争的情况下，使用轻量级锁比重量级锁更慢。偏向锁的执行过程代码进入同步快，如果没有被锁定(标志位为”01”)，那么在当前线程的栈帧中建立一个锁记录(Lock Record)的空间，存储当前对象的Mark Word(因为对象头需要记录锁相关的内容)然后虚拟机使用CAS操作将对象的Mark Word更新为 Lock Record的指针，如果成功了，那么线程有了对象的锁，将Mark Word的锁标志变成“00” 图中画错了。如果跟新失败了，那么检查对象的Mark Word是否指向当前线程的栈帧，如果是则已经获得锁直接进入同步快，否则锁被其他线程抢占了。如果多个线程竞争同一个锁，那么轻量级锁没用了，升级为重量级锁。]]></content>
      <categories>
        <category>JVM虚拟机原理</category>
      </categories>
      <tags>
        <tag>JVM原理</tag>
        <tag>线程安全与锁优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机 第8章 虚拟机字节码执行引擎]]></title>
    <url>%2F2018%2F08%2F14%2FJVM-8%2F</url>
    <content type="text"><![CDATA[第8章 虚拟机字节码执行引擎 JAVA虚拟机规范中规定了虚拟机字节码执行引擎的概念模型。从概念模型的角度讲解虚拟机的方法调用和字节码执行。 运行时栈帧结构栈帧时用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时的数据区虚拟机栈的栈元素。栈帧中保存了方法调用的局部变量表，操作数栈，动态链接和方法返回地址等信息。每一个方法的开始执行到执行完毕对应着栈帧在虚拟机栈中的入栈和出栈操作。一个线程中的方法调用链可能很长，在活动线程中，只有栈顶的栈帧才是有效的。 局部变量表局部变量表是一组变量值存储空间，主要来保存方法参数和方法内定义的局部变量。在java代码编译时确定了该方法所需分配的局部变量表的最大容量。局部变量的存储单位是slot，一个Slot可以存放一个32位以内（boolean、byte、char、short、int、float、reference和returnAddress）的数据类型，reference类型表示一个对象实例的引用，returnAddress已经很少见了，可以忽略。对于64位的数据类型，long和double采用高位对齐的方式分配连续的两个slot。 对于reference类型表示对一个对象实例的引用，该引用有2个用处。 使用该引用找到java堆中该对象的存储的地址索引。 使用该引用可以找到该对象所属类的数据类型在方法区中存储的类型信息，其实就是该类的class对象的信息，class对象比较特殊，存储在方法区中。(对象头里面也有class地址的信息) java虚拟机通过索引定位的方式来使用局部变量表，索引范围是从0到最大值。0代表的是this指针。索引n代表使用了第n个slot，64位的数据是连续使用n和n+1的slot。slot可以被复用，为了节省空间。类变量表一般有2次的初始化机会，一次是在类加载的准备阶段为类变量赋零值，执行系统的初始化。另一个是在类加载的初始化阶段，赋程序猿在代码定义的初始值。但是局部便利那个不存在系统初始化的阶段，这意味着定义的局部变量必须认为初始化。 操作数栈操作数栈是一个后进先出的数据结构，当方法执行时，方法中的操作数对应着入栈和出栈的操作。即会各种指令向操作数栈中写入和提取内容。 在概念模型中，一个活动线程的两个栈帧是相互独立的，但是虚拟机会做优化处理，让下一个栈帧的部分操作数栈和上一个栈帧的局部变量表重叠，可以共享一部分数据，无需额外的数据赋值传递。 动态链接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有引用为了支持方法调用过程的动态链接。class文件中的常量池中存在大量的符号引用，字节码的方法调用指令是以指向常量池中的符号引用作为参数的。则可以通过字节码迅速定位到具体的方法代码。一部分符号引用在类加载或者第一次使用时转化成直接引用，这种转化称为静态解析。另一部分在每次运行时才转为直接引用，称为动态链接。 方法返回地址存放调用该方法的计数器的值。当一个方法开始后有2种方式退出。&nbsp;&nbsp;&nbsp;&nbsp;1. 遇到return返回，正常退出。&nbsp;&nbsp;&nbsp;&nbsp;2. 遇到异常，并且这个异常在方法内没有catch，即在方法内部没有匹配的异常处理器，导致方法退出，方法异常退出不会给调用者返回任何值。无论哪种方法退出后都会返回该方法调用的位置，正常退出使用计数器的值作为地址，异常退出要通过异常处理表来确定返回地址。 方法调用方法调用阶段是为了确定调用方法的版本，即具体调用的是哪一个方法，方法调用和方法执行不同，调用阶段不涉及方法内部的运行过程。==在class文件中存储的都只是符号引用而不是具体的内存布局的入口。只有在类加载阶段或者运行期间才能确定方法的直接应用。== 方法的解析在类加载的解析阶段，会将一部分的符号引用转化成直接引用，这个解析成功的前提条件是：方法在程序真正运行前就有一个可以调用的版本，并且这个版本在运行期间不可改变。java中的static方法，private方法，init方法和父类方法是“编译期克制，运行期不可变的”。可以在类加载期间进行解析。java虚拟机中提供了5中方法调用字节码 &nbsp;&nbsp;&nbsp;&nbsp;1. invokestatic:调用静态方法 &nbsp;&nbsp;&nbsp;&nbsp;2. invokespecial:调用构造器，私有方法和父类方法 &nbsp;&nbsp;&nbsp;&nbsp;3. invokevirtual:调用虚方法 &nbsp;&nbsp;&nbsp;&nbsp;4. invokeinterface:调用接口方法 &nbsp;&nbsp;&nbsp;&nbsp;5. invokedynamic：现在运行时动态解析出该方法，然后执行。 其中，invokestatic和invokespecial指令调用的放啊都可以在解析阶段找到唯一调用版本。符合这个条件的有静态方法，私有方法，实例构造器，父类方法。在类加字啊 12345678910111213141516171819202122public class MethodInvokeTest &#123; public static void sayHello()&#123; log.info("我是不可改变的，任何方式都无法改变我的结构..."); &#125; // 为了对比说明，我们来看一下一个普通的方法sayHello() public void eatApple()&#123; log.info("我是可以改变的，子类可以通过继承改变我的结构"); &#125;&#125;public class MethodInvokeExtendsClass extends MethodInvokeTest&#123; public void eatApple()&#123; log.info("我输出我自己的内容..."); &#125; public static void main(String[] args) &#123; MethodInvokeExtendsClass methodInvokeExtendsClass = new MethodInvokeExtendsClass(); // invokespecial指令 methodInvokeExtendsClass.eatApple(); // invokevirtual指令 --输出：我输出我自己的内容... MethodInvokeTest.sayHello(); // invokestatic指令 --我是不可改变的，任何方式都无法改变我的结构... &#125;&#125; 方法的分派方法的解析是一个静态的过程，==在编译期间可以得到最终的版本==，在类加载的解析阶段可以把涉及的符号引用全部转化成直接饮用，而方法的分派(Dispacher)调用可能是静态的也可能是动态的。 静态 Dispather静态分派我理解的最常见的就是方法的重载(overload)了。即在编译期间就要确定是调用哪一个方法。具体代码如下： 123456789101112131415161718192021222324252627282930public class StaticDispatchTest extends Object&#123; final static Log log = LogFactory.getLog(StaticDispatchTest.class); // 父类 static abstract class Fish&#123;&#125; // 子类：鲫鱼 static class Jiyu extends Fish&#123;&#125; // 子类：鲤鱼 static class Liyu extends Fish&#123;&#125; // 下面写几个重载的方法 public void swimming(Fish fish)&#123; log.info("我是鱼，我用鱼鳍游泳..."); &#125; public void swimming(Jiyu jiyu)&#123; log.info("我是鲫鱼，我用鱼鳍游泳..."); &#125; public void swimming(Liyu liyu)&#123; log.info("我是鲤鱼，我用鱼鳍游泳..."); &#125; // 测试 public static void main(String[] yangcq)&#123; Fish jiyu = new Jiyu(); Fish liyu = new Liyu(); StaticDispatchTest staticDispatchTest = new StaticDispatchTest(); staticDispatchTest.swimming(jiyu); // 打印：我是鱼，我用鱼鳍游泳... staticDispatchTest.swimming(liyu); // 打印：我是鱼，我用鱼鳍游泳... &#125;&#125; 在方法的重载时是通过参数的静态类型而不是实际类型作为判定依据的。静态类型在编译期间可知的。因此，在编译期间，javac可以根据参数的静态类型确定调用那个重载版本。jiyu和liyu的静态类型都是Fish。并且静态分配时发生在编译期间，会自动寻找最合适的函数绑定。 动态Dispather动态Dispather的主要体现时在override上，代码如下 1234567891011121314151617181920212223242526public class DynamicDispatchTest extends Object&#123; // 父类 static abstract class Fish&#123; public void swimming()&#123; System.out.println("我是鱼，我用鱼鳍游泳..."); &#125; &#125; // 子类：鲫鱼 static class Jiyu extends Fish&#123; public void swimming()&#123; System.out.println("我是鲫鱼，我用鱼鳍游泳..."); &#125; &#125; // 子类：鲤鱼 static class Liyu extends Fish&#123; public void swimming()&#123; System.out.println("我是鲤鱼，我用鱼鳍游泳..."); &#125; &#125; public static void main(String[] yangcq)&#123; Fish jiyu = new Jiyu(); Fish liyu = new Liyu(); jiyu.swimming(); // 打印：我是鲫鱼，我用鱼鳍游泳... liyu.swimming(); // 打印：我是鲤鱼，我用鱼鳍游泳... &#125;&#125; 正常的方法调用都是调用invokeVirtual方法，invokeVirtual方法的解析 找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C； 在类型C中找到与常量描述符相同的类型和方法，直接通过offset来找找到。然后返回改方法的直接引用地址。 如果在C中没有该方法，就从C的父类中去查找，直到找到具体调用的方法，如果没有找到，就抛出异常。由于invokevirtual指令执行的第一步就是在运行期间确定接收者的实际类型，所以2次调用中的invokevirtual指令把常量池中的类方法的符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种运行期间根据实际类型确定方法执行版本的分派过程称为动态分派。 虚拟机动态分派的实现动态分派的实现是在类加载的时候在方法区中建立一个虚方法表， 用虚方法表来代替元数据的查找来提高性能。虚方法表中存放的是各个方法的实际入口地址。如果方法没有被重写，就和父类的入口地址一样，否则用子类自己的地址。同时，相同的签名的方法，在父类和子类的虚方法表中应当有相同的索引序号，这样在类型转换时候可以方便改变查找的虚函数表。虚方法表一般在类加载的准备阶段初始化。]]></content>
      <categories>
        <category>JVM虚拟机原理</category>
      </categories>
      <tags>
        <tag>JVM原理</tag>
        <tag>虚拟机字节码执行引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM原理 第2章 java运行时数据区]]></title>
    <url>%2F2018%2F08%2F12%2FJVM-2%2F</url>
    <content type="text"><![CDATA[Java内存区域与内存溢出异常2.2 运行时数据区域&emsp;&emsp;java虚拟机在运行程序时会把管理的内存分为几个不同的数据区域，这些区域的作用不同并且创建和销毁的时间不同。java虚拟机将管理的内存分为以下几个数据区域。1234567线程共享部分1. 方法区2. 堆线程私有部分3. 虚拟机栈4. 本地方法栈5. 程序计数器 2.2.1 程序计数器&emsp;&emsp;一块比较小的内存区域，看成当前线程执行字节码的行号指示器。通过改变这个值来取下一条的指令，分支、循环、跳转、异常处理、线程恢复都是靠这个计数器来完成。&emsp;&emsp;java的多线程时通过线程轮流切换并分配处理器的执行时间来实现。为了线程切换后能恢复到正确的执行位置，每个线程需要独立的程序计数器，各个线程的程序计数器相互不影响。&emsp;&emsp;如果线程执行java方法，这个计数器记录正在执行的虚拟机字节码指令的地址，如果是执行native方法，计数器的值为空(undefined)。此内存区域为java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2.2.2 java虚拟机栈&emsp;&emsp;java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，生命周期和线程相同。虚拟机栈描述的是java方法执行的内存模型。在调用方法的同时会创建一个栈帧(Stack Frame)来存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用到执行完成对应栈帧在虚拟机栈中的入栈道出栈的过程。&emsp;&emsp;局部变量表中存放的是编译期间可知的基本数据类型(boolean, byte, char, short, int, float, long, double)、对象引用类型(reference类型),是指向堆对象的一个引用。其中long和double数据类型占用2个slot槽，其余占用一个slot槽。一个槽指向一个地址，long和double需要两个地址空间存放64位的数据，则需要两个slot。局部变量表的所需的空间在编译期间完成，在放啊运行期间不会改变局部变量表的大小。 &emsp;&emsp;在方法中声明的是基本类型的变量时，变量名和值(变量名和值时两个概念)是存放在方法栈中，申明的事引用变量时，对象的内存地址是存放在栈中。&emsp;&emsp;类中声明的是基本基本变量，称为全局变量，变量名和值都是存放在堆中。引用类型存放的是对象的地址。 &emsp;&emsp;在java虚拟机规范中对这个区域规范两种异常，线程请求的栈深度超过虚拟机提供的深度，抛出StackOverflowError异常，如果方法无法申请足够的内存，抛出OutOfMemoryError异常。 2.2.3 本地方法栈本地方法栈(Native Method Stack)和虚拟机栈类似。只是本地方法栈是为虚拟机使用到的native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java堆&emsp;&emsp;Java堆是虚拟机管理内存最大的部分。是线程共享的。在虚拟机启动的时候创建。存放的是实例对象。 java堆是垃圾收集器管理的主要部分。所以也称为GC堆。 线程共享的java堆中可以划分出线程私有的分配缓冲区(TLAB thread local allcation buffer)。 2.2.5 方法区方法区中存放的是被虚拟机加载的类信息，常量，静态变量，编译后的代码等。GC分代收集扩展至方法区。 2.2.6 运行时常量池class文件中出了类的版本，字段，方法等信息还有常量池，存放编译期间生成的各种字面量和符号引用，该部分在类加载后放在方法区中的运行时常量池中存放。在运行期间也会将新的常量放入池内。比如String的intern()方法。 2.2.7 直接内存在NIO类中，引入了基于通道(channel)与缓冲区(Buffer)的I/O方法，可以使用Native函数直接在堆外分配内存，然后通过存储在java堆中的DirectByteBuffer对象作为这个内存的引用操作。可以提高性能，避免在Java堆和native堆中来回复制数据。显然，本机直接内存不会受到java堆大小的限制，但是受到本机的物理内存的影响。 2.3 对象的创建过程 当虚拟机遇到一个new指令，首先检查这个指令的参数在常量池能定位到一个符号引用，再检查这个符号引用的类是否被加载，解析和初始化，没有要先执行类加载过程。 将一块等同该对象大小的空间从java堆中划分出来，一般是维护一个队列，记录可用的内存。 为了保证分配对象的线程安全，1.使用TLAB来分配2.使用CAS来进行失败重试保证内存分配的原子性。 分配完对象，需要对内存空间进行初始化为零值。并且设置对象的对象头的一些值，比如哈希值，GC年代等等。 上述工作完成后，虚拟机角度看一个对象产生了，但是从java程序看，对象还没有初始化，因为没有执行方法。 对象的内存布局在虚拟机中，一个对象在内存中的分配区域主要有：对象头，实例数据，对其补充。如图所示 对象头对象头中主要有Mark Word和指向class元类型的指针。 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳、对象分代年龄，这部分信息称为“Mark Word”；Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间。 第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中无法确定数组的大小。这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit。 例如，在 32 位的 HotSpot 虚拟机中，如果对象处于未被锁定的状态下，那么 Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，如下表所示： 在 32 位系统下，存放 Class 指针的空间大小是 4 字节，Mark Word 空间大小也是4字节，因此头部就是 8 字节，如果是数组就需要再加 4 字节表示数组的长度，如下表所示： 在 64 位系统及 64 位 JVM 下，开启指针压缩，那么头部存放 Class 指针的空间大小还是4字节，而 Mark Word 区域会变大，变成 8 字节，也就是头部最少为 12 字节，如下表所示： 压缩指针：开启指针压缩使用算法开销带来内存节约，Java 对象都是以 8 字节对齐的，也就是以 8 字节为内存访问的基本单元，那么在地理处理上，就有 3 个位是空闲的，这 3 个位可以用来虚拟，利用 32 位的地址指针原本最多只能寻址 4GB，但是加上 3 个位的 8 种内部运算，就可以变化出 32GB 的寻址。 实例数据实例数据是对象存储的有效信息，在程序代码中定义的各种类型的字段内容。 对齐补充由于HotSpot VM的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是说对象的大小必须是 8 字节的整数倍。对象头部分是 8 字节的倍数，所以当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 估算对象大小32 位系统下，当使用 new Object() 时，JVM 将会分配 8（Mark Word+类型指针） 字节的空间，128 个 Object 对象将占用 1KB 的空间。如果是 new Integer()，那么对象里还有一个 int 值，其占用 4 字节，这个对象也就是 8+4=12 字节，对齐后，该对象就是 16 字节。 以上只是一些简单的对象，那么对象的内部属性是怎么排布的？ 12345Class A &#123; int i; byte b; String str;&#125; 其中对象头部占用 ‘Mark Word’4 + ‘类型指针’4 = 8 字节；byte 8 位长，占用 1 字节；int 32 位长，占用 4 字节；String 只有引用，占用 4 字节；那么对象 A 一共占用了 8+1+4+4=17 字节，按照 8 字节对齐原则，对象大小也就是 24 字节。 这个计算看起来是没有问题的，对象的大小也确实是 24 字节，但是对齐（padding）的位置并不对： 在 HotSpot VM 中，对象排布时，间隙是在 4 字节基础上的（在 32 位和 64 位压缩模式下），上述例子中，int 后面的 byte，空隙只剩下 3 字节，接下来的 String 对象引用需要 4 字节来存放，因此 byte 和对象引用之间就会有 3 字节对齐，对象引用排布后，最后会有 4 字节对齐，因此结果上依然是 7 字节对齐。此时对象的结构示意图，如下图所示： 对象的访问定位在访问对象时，通过栈上的reference数据类操作堆上的具体对象。reference类型在具体的访问对象有2种方式： 使用句柄访问，&nbsp;&nbsp;&nbsp;&nbsp;在java堆中划分一块区域为句柄池，reference存储的是对象的句柄地址，句柄中包含对象的实例地址和对象类型。对象类型是通过对象头的指针来访问 直接指针访问&nbsp;&nbsp;&nbsp;&nbsp;reference存储的是对象的直接地址。]]></content>
      <categories>
        <category>JVM虚拟机原理</category>
      </categories>
      <tags>
        <tag>JVM原理</tag>
        <tag>java运行时数据区</tag>
        <tag>对象创建</tag>
        <tag>对象访问定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机 第3章 垃圾回收器和内存分配策略]]></title>
    <url>%2F2018%2F08%2F12%2FJVM-3%2F</url>
    <content type="text"><![CDATA[垃圾回收和内存分配策略垃圾收集(Garbage Collection, GC)主要关注的是java堆。因为虚拟机栈，本地方法栈，程序计数器都是随着线程的产生和消失。所以这部分的内存分配是在编译器可知。对它的内存分配是确定的。对于java堆的对象实例，只有在运行期间才知道创建那些对象实例，则这部分的内存分配和回收是动态的。 引用计数算法给对象添加引用计数器，有引用就值加1，失效就减1.计数器为0就不可能再被使用。效率高，但是不能解决对象相互引用的问题。GC Rootsde 的可达性分析来判断对象是否存活。比如 12345678910public class A&#123; public Object instance = null;&#125;A a1 = new A();A a2 = new A();a1.instance = a2;a2.instance = a1;a1 = null;a2 = null;System.gc(); 则a1 和a2 应该要被回收的，但是他们有引用，不可能被回收的问题。可达性分析算法:通过一系列的称为”GC Roots”的对象作为起始点。当对象到GC Roots之间有可达的引用连认为对象可用。否则就认为对象不可达，可以回收。当一个对象到GC Roots 没有任何链相连就认为对象是不可用的。作为GC Roots的对象包括: * 虚拟机栈(栈帧的本地变量表)中引用的对象。 2.本地方法栈中的JNI(native 方法)引用的对象。 3.方法区中的常量或者类静态属性引用的对象。 // static的属性引用的对象 因为static是类加载就生成对象了 引用类型 1234567891011121314151617181920212223 1、强引用 new出来的对象，只要引用存在，该对象就不会被回收 2、软引用 SoftReference 引用一些有用但并非必须的对象，当系统出现内存溢出异常之前会对软引用的对象进行回收，回收后还没有足够的内存才会内存溢出 3、弱引用 被弱引用关联的对象只能生存到下一次的垃圾回收之前。即对象被引用了还是会被回收。WeakReferemce 4、虚引用 无法通过虚引用来获得对象的实例，设置虚引用的目的是对象被垃圾回收时收到一个系统通知。PhantomReference ``` ## 回收方法区回收方法区方法区(永久代)回收两个部分：废弃常量和无用的类。回收废弃常量比较简单。只要没有对象引用这个常量就可以将该常量移出常量池。**在常量池中有“abc”这个字符串，只要没有任何的String对象引用这个对象，该对象就会被回收。** 回收无用的类： 1.对象的实例被全部回收。 2.加载该类的classloader被回收。 3.class对象没有被引用，无法通过反射调用该类的方法。 该类可以被回收。 可达性分析：```java1. Object aobj = new Object ( ) ;2. Object bobj = new Object ( ) ;3. Object cobj = new Object ( ) ;4. aobj = bobj;5. aobj = cobj;6. cobj = null;7. aobj = null; 第4行和第7行都会导致有对象被回收。因为aobj、bobj、cobj都是虚拟机栈的局部变量表中的reference所指的对象。而其中new的3个object是存放在java堆中的。那么如果aobj=bobj后，那么aobj所指向的object就没有gc roots的引用链可以引用，就会被回收。而cobj也会被回收。 1231. String str = new String("hello");2. SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String("java"));//软引用3. WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(new String("world")); //弱引用 第二个在内存不足会被回收，第三个一定会被回收。 总结下常用的会被回收的情况 1.显示的将引用赋值为null或者将已经指向某个对象的引用指向新的对象。 123451. Object obj = new Object();2. obj = null;3. Object obj1 = new Object();4. Object obj2 = new Object();5. obj1 = obj2; 2.局部引用指向的对象 1234567void fun() &#123;..... for(int i=0;i&lt;10;i++) &#123; Object obj = new Object(); System.out.println(obj.getClass()); &#125;&#125; 循环每执行一次，生成的object对象都会被回收。 3.只有若引用与其关联的对象 1WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(new String("world")); 垃圾回收算法：Mark-Sweep（标记清除算法） 标记出所有需要被回收的对象，清除就是回收所有的标记对象的占用的内存。 图中看出容易产生碎片。后续无法为大的对象分配内存。 复制算法将内存分为相等的2快，每次垃圾回收将存活的对象全复制到另外一般的干净的内存中，然后对整半个内存清理。 不需要考虑内存碎片等情况。缺点：内存缩小到原来的一半。现在的虚拟机都是采用这个方法来收集新生代：新生成的对象98%是要死的。那么存活的对象很少。可以把内存分为1个较大的Edge区域和2个Survicor空间。比例为8：1。那么每次回收就把Survivior的对象和Eden对象的存活对象复制到另一个Survivor区间。然后清理刚刚所有的Edge和Survivor区间的对象。当一个survivor中不能存放所有的存活对象时候，这些对象会直接通过担保机制进入到老年代。 当一个新生对象经过15次的垃圾回收后还存活，就将对象移动到老年代。 标记-整理算法标记复制算法在对象存活率较高时候要进行过多的复制操作，效率比较低。不想浪费50%的空间，还需要额外的空间担保分配以应对内存中100%的对象都存活的极端条件。所以在老年代中不使用这个方法，而是用标记整理算法。因为老年代的对象存活率较高 将对象标记，完成标记后将所有的存活对象都往一端移动，然后清理边界以外的内存。有点：充分利用内存。 分代收集算法 将对象分为新生代和老年代。对新生代采用复制算法。对老年代就采用标记-清理或者标记-整理。 ==枚举根节点：== 可作为GC Roots的节点主要是全局性引用（(常量池中)常量和(方法区中)类的静态属性变量）和 执行上下文(帧栈中的本地变量表)。但是有些方法区就有数百兆。那么如何快速定位常量、静态变量或者本地变量表。 需要使用OopMap数据结构。记录下栈和寄存器那些位置是引用。这样GC扫描直接可以得到GC Roots 。 安全点：导致OopMap变化的指令很多。那么就要就要设定在特定的地方记录OopMap。“让程序长时间执行的特征”设立安全点。比如方法调用、异常跳转、循环跳转等。产生safepoint。 线程安全： 在gc调用时，要暂停全部线程(除了虚拟机调用的线程)。那么有两种方案。 1. 抢先式中断 如果发生gc，就把所有的线程都中断。 2. 主动式中断 如果gc需要中断，就设定标志，各线程去轮训这个标志. 线程休眠：当线程休眠，无法响应JVM的中断请求。就进入&quot;安全区域&quot;。对安全区域的内容不用线程中断。直接清理。当线程开始后，要等清理完毕后才能开始工作。 典型的垃圾收集器： serial/serial old 收集器单线程收集器进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。 ParNew收集器多线程版本。 CMS收集器 一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是标记-清除算法。分为以下4个步骤1.初始标记 //暂停所有线程. 2.并发标记 3.重新标记//暂停所有线程 4.并发清除 产生大量的内存碎片，需要内存紧缩操作，这个过程不能并行。在并发清除时候要和用户线程一起操作，会降低效率。 G1收集器G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。对新生代支持标记复制算法，对老年代支持标记整理算法。同时维护一个可预测时间大小的region域，根据时间要求去清除最优价值的区域。 内存分配和担保策略java的内存分配就是如何在堆上分配对象，对象主要分配在新生代的Eden区域，如果启动了本地内存分配缓冲，则将按线程有限在TLAB分配，在少数情况下也会分配在老年代。 对象优先在Eden分配&nbsp;&nbsp;&nbsp;&nbsp;小对象在Eden区分配，当Eden区没有足够的空间区域分配就会发起一次Minor GC。 大对象直接进入老年代&nbsp;&nbsp;&nbsp;&nbsp;大对象指需要连续内存空间的JAVA对象，一般是大String或者大数组，比如一个new Integer[1024]的对象就会分陪在老年代。 长期存活的对象会直接进入老年代&nbsp;&nbsp;&nbsp;&nbsp;虚拟机为每个对象分配一个age计数器，对象在Eden区出生并且经过一次minor gc后存活就被移动到survivor区域，并且age+1，每次经过minor gc就会年龄+1，当age增加到一定值(默认15)，会被移动到老年代。 动态对象年龄判断&nbsp;&nbsp;&nbsp;&nbsp;在survivor区域的相同年龄的所有对象的内存总和大于survivor空间的一半，年龄大于或者等于这个对象的直接进入老年代，无需默认的15的要求。 空间担保策略&nbsp;&nbsp;&nbsp;&nbsp;在发生Minor GC时，虚拟机都会先检查老年代的最大连续可用空间是否大于新生代的所有对象空间。如果成立，则Minor GC是安全的。如果小于的话，就会先进行一次Full GC。新生代采用复制收集算法，使用一个Survivor空间来做备份，当Minor GC后还出现大量的存活对象，survivor无法存储的对象将直接进入到老年代。前提是老年代有足够的空间容纳这个对象。反正老年代的空间不足就会full gc(我是这么理解的)]]></content>
      <categories>
        <category>JVM虚拟机原理</category>
      </categories>
      <tags>
        <tag>JVM原理</tag>
        <tag>垃圾回收</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM原理 第12章 java内存模型和线程]]></title>
    <url>%2F2018%2F08%2F07%2FJVM-12%2F</url>
    <content type="text"><![CDATA[java内存模型和线程 JVM的内存模型是为了解决虚拟机实现多线程，但是多线程之间共享和竞争数据导致的问题。 硬件的效率与一致性计算机的存储设备和cpu的运算能力之间存在数量级之间的差距，所以现代计算机系统会在内存和cpu之间再插入告诉缓存cache，cache的速度和cpu的速度一致。这样的好处是每次运算都会先将数据复制到缓存中，在进行cpu计算，计算结束后再讲结果从缓存同步到内存中，这个cpu无需每次都等待缓慢的内存读写了。存在问题：缓存一致性 每个cpu都有自己的高速缓存，同时共享同一个主内存。当多个处理器处理涉及同一个内存，需要有一致性协议来保证数据一致性。同时为了使处理器内部的运算单元能被充分利用，处理器对输入的代码会进行乱序处理优化，处理器会保证结果的正确性 java内存模型 java的内存模型定义了虚拟机将变量存储到内存和从内存中取出变量这样的细节，包括实例字段，静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是私有的，不会被共享，不存在竞争问题。 Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示 注意： reference变量是局部变量中，是线程私有的，但是它的实例对象是共享的。 拷贝副本不会一次性拷贝10m的变量。volatile变量还是有工作内存的拷贝，但是它的操作顺序由特殊的规定，使它的操作就像在主内存中访问。 这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。 内存间交互操作java内存模型规定了如下8种操作来完成主内存和工作内存之间的数据交互，虚拟机保证如下8种操作是原子性的。 lock 作用主内存的变量 把一个变量标识为线程独占的状态 unlock 作用主内存的变量 把一个变量从锁定状态释放出来，该变量可以被其他线程锁定 read 作用主内存的变量 把一个变量从主内存传输到工作内存，使可以被loan动作使用 loan 作用于工作内存 把从主内存read的变量载入工作工作内存的变量副本中 use 作用于工作内存 把工作内存的变量传递给cpu，当虚拟机遇到需要读取变量的字节码会执行该指令 assign 作用于工作内存 把cpu的执行结果赋值给工作内存副本 store 作用于工作内存 把工作内存的变量传输到主内存 write 把工作内存传输的变量存到主内存的变量中。 java内存模型规定了在执行上述的8中基本操作还要满足如下规则 read 和loan 必须同时出现，即工作内存从主内存读取了对象后必须接收 不能丢弃assign操作，即工作内存的变量变化了必须同步到主内存中 没有发生assign，不能将工作内存的变量同步到主内存 lock时会清空工作内存的值，cpu需要使用这个值时必须重新loan 在unlock之前，会先将变量同步到主内存。 如下的4条看上去是原子性的操作其中只有第一个是原子性，JVM保证简单的内存赋值是原子性，y=x首先要读取x变量的值，再将x的值赋给y，x++和x=x+1肯定不是原子性的操作。 1234x = 1y = xx++x = x + 1 volatile变量的特殊规定在使用了volatile变量后，当一个线程修改了这个值，另一个线程都会立刻得知。 如果是普通的变量，只有A线程修改了值，写回主线程，B线程再读取内存的值才可以。volatile的操作规定，v和w都是volatile变量： 线程T每次use变量v之前都要执行loan操作，loan操作和read必须同时出现。即（在工作内存中，每次使用v都会从主内存刷新得到最新的值，来保证能看见其他线程对变量v所做的改变。） 线程assign后必须执行store，store和write会同步出现，即(在工作内存中，每次修改v后必须同步回主内存中，用来保证其他线程能立即看见自己对变量v的修改) 保证volatile修饰的变量不会指令重排序优化，保证代码的执行顺序和程序的顺序相同。 volatile保证在将修改同步到内存之前，所有之前的操作都已经执行完毕，形成指令重拍序无法越过内存屏障，即保证了volatile之前的指令都已经执行完毕，在volatile之后的指令都没有执行。但是不保证其他指令的重拍序。volatile保证了指令不会被乱序，如果initialized没有使用volatile，那么可能由于指令重排序导致线程A的最后的initialized = true被提前执行，则线程B使用配置文件会出错。 volatile解决DCL(双重检查)问题 单例使用DCL写的懒汉式单例模式如下所示 12345678910111213141516171819202122232425public class Singleton &#123; private static Singleton instance = null; private int age; public static Singleton getInstance() &#123; if(instance == null) &#123; //1 synchonorized(Singleton.class) &#123; //2 if(instance == null) &#123; //3 instance = new Singleton(); //4 &#125; &#125; &#125; return instance; //5 &#125; public Singleton() &#123; this.age = 18; &#125; public int getAge() &#123; //6 return age; &#125;&#125; 在一般情况下该单例模式可以正常工作，但是在多线程调用该单例还是会出现并发的问题。因为可能线程会得到一个并未完全构造完成的对象。比如当A线程访问getinstance()方法，在//1出instance == null 返回true，获得锁进入同步代码块，此时线程B也访问getInstance()方法，线程B在//1处instance==null可能会返回false，但是此时instance并未完全初始化完成，线程B得到一个完全初始化的instance，线程B在调用//6时可能不能拿到age=18的结果，此时DCL的问题就出来了。问题就出在指令重排序的问题。 问题出现的原因instance = new Singleton()这一句话不是原子操作，它的操作可以分为如下三个部分： 分配内存空间 实例化对象instance 把instance引用指向的已分配的内存空间，此时instance有了内存地址，不再是null了 java允许对指令进行重排序，那么以上3步的执行顺序就可能是1-3-2，在这种情况下如果线程A执行完1-3后被阻塞了，此时线程B进来获得了instance的引用，因此此时instance不为空，直接到//1就返回了获得了没有实例完全的对象。 使用volatile可以避免这个问题，因为volatile的对象保证不会被指令重拍序，在操作volatile对象之前的代码一定是执行完毕并且可见，在变量操作之后的代码一定是还没有被执行的。所以当instance被定义成volatile时，保证创建的顺序一定是1-2-3，instance一定是null或者完全初始化完成的对象。其实可以创建成一个static类并获取对象，因为虚拟机会自动保证静态变量的并发。synchonorized不会对分配内存的操作防止指令重拍序，它只能保证在它离开同步代码块前把变化的变量都刷新回主内存。所以会存在instance不为null，但是对象还没有构造完成。 12345678910111213141516171819202122232425public class Singleton &#123; private volatile static Singleton instance = null; private int age; public static Singleton getInstance() &#123; if(instance == null) &#123; //1 synchonorized(Singleton.class) &#123; //2 if(instance == null) &#123; //3 instance = new Singleton(); //4 &#125; &#125; &#125; return instance; //5 &#125; public Singleton() &#123; this.age = 18; &#125; public int getAge() &#123; //6 return age; &#125;&#125; volatile和synchonorized的区别 volatile和synchonorized都保证了可见性，volatile是通过强制刷新到主内存保证，synchonorized是对一个变量进行unlock时必须先同步到主内存中。 volatile防止了指令重拍序，synchonorized保证了两个线程进入同步代码块的先后性保证了有序性，两者的原理有本质的区别。 volatile变量在并发下不安全volatile变量规定对所有线程都是立即可见的，对volatile的所有写操作都是可以立刻反应到其他的线程中。虽然volatile变量不存在一致性问题，但是java运算操作不是原子性的，所以volatile变量的运算不是安全的。还volatile变量禁止指令重排序。比如自加操作。race++这个过程需要有多个步骤，将race的值取到栈顶，这个过程是正确的，但是接下来的自加操作中如果有其他的线程往主内存写数据就会使数据写回出错。写回去的值可能会比理论值小。什么情况下可以使用volatile变量 运算结果不依赖当前值，或者确保只能一个线程可以修改变量的值2。 变量不需要其他的状态变量共同参与不变约束。 ##原子性，可见性，有序性java的内存模型都是围绕着在并发过程中如何处理原子性，可见性，有序性三个特征建立的 原子性 &nbsp;&nbsp;&nbsp;&nbsp;java内存模型直接保证8个基本操作是原子性的，如果要在大范围内保证原子性，必须使用monitorenter和monitorexit来隐式使用，这个反映到java代码就是同步代码块synchonorized关键字，即synchonorized的代码是原子性的。 可见性 &nbsp;&nbsp;&nbsp;&nbsp;一个线程修改了变量的值，其他的线程能立刻得到这个新的值。如volatile变量，除了这个变量，synchronized和final也可以完成可见性。final字段初始化后就能立刻被其他线程访问。 有序性 &nbsp;&nbsp;&nbsp;&nbsp;线程内表现为串行的操作，在其他的线程看来是无序的。包括指令重排序和主内存同步延迟现象。 对于可见性，violatile保证可见性，synchonorized和final也能保证可见性。synchonorized同步快的可见性是“对一个对象执行unlock前必须将变量同步到主内存(执行store，write)中”保证，我理解同步块是保证了在同步代码块中变化的变量都必须刷新到主内存中才会释放锁。final关键字的可见性是被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”引用传递出去，那么其他线程就能得到正确的值。this指针逃逸是一件危险的事情，其他线程可能访问到初始化了一半的对象。对于有序性，violatile和synchonorized都能保证有序性，violatile是防止指令重排序，synchonorized是由一个变量在同一时刻只能一个线程对其lock操作的这个规则获得的==。则决定了同一个锁的两个同步快只能串行的进入。ReentrantLock是使用CAS来保证同步性，也能保证原子性，可见性，有序性。通过内置的volatile state来保证。因为volatile会保证先行发生原则。也可以理解为读取volatile前将其之前的变量都刷新到主内存中，并使其他的缓存失效 ###先行发生原则虚拟机可以对不满足先行原则的指令进行任意顺序的重排序。满足先行发生原则的规则如下： 程序次序原则&nbsp;&nbsp;&nbsp;&nbsp;在一个线程内，代码按照顺序执行 管程锁定规则&nbsp;&nbsp;&nbsp;&nbsp;对同一个锁，unlock操作时间上先行发生于后面的lock操作 volatile变量规则&nbsp;&nbsp;&nbsp;&nbsp;对一个volatile变量的写操作先于度操作 线程启动原则&nbsp;&nbsp;&nbsp;&nbsp; Thread的start()先于该线程的任何操作 线程终止原则&nbsp;&nbsp;&nbsp;&nbsp;Thread的所有操作都先于线程的终止检测。可以通过Thread.join()和Thread.isAlive()的返回值检测线程是否已终止 线程终端规则 线程的interrupt()方法先于中断线程检测到中断事件的发生，即可以使用interrupted()方法检测到线程是否被中断了。 对象终结原则 对象构造函数执行完毕先于finilized()方法 传递性 A先于B，B先于C。保证A先于C java和线程线程是比进程轻量级的调度单位。各个线程可以共享进程的资源(内存地址，文件I/O)等，又可以独立调度。线程是CPU调度的基本单位实现线程一般有3种实现方式，内核线程实现，用户线程实现，用户线程加轻量级进程混合实现。 内核线程&nbsp;&nbsp;&nbsp;&nbsp;内核线程(Kernal-Level Thread KLT) 由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过调度器对线程进行调度，支持多线程的内核叫做多线程内核。程序一般会使用内核线程的一种高级接口–轻量级进程(Light Weight Process LWP)轻量级进程就是通常意义的线程，每个轻量级进程都是由一个内核线程支持，因此先有内核线程，才能有轻量级进程。之间的数量关系为1：1。==内核线程耗时好资源，无法创建大规模的内核线程，并发数量低。== 用户线程&nbsp;&nbsp;&nbsp;&nbsp;系统内核感知不到用户线程的存在。线程的创建，同步，销毁，调度都由用户态完成。优点：快速低耗，可以支持更大规模的线程数量。缺点：很难实现线程的调度。==因为CPU只会调度内核线程，用户线程没有内核线程的支持无法处理切换和调度。这个部分都需要用户自己去实现，比如当一个线程死循环不放弃CPU资源，其他线程将用户无法得到执行。== 用户线程加上轻量级进程混合实现&nbsp;&nbsp;&nbsp;&nbsp;该方法使用户线程的创建，切换，调度方便，支持大规模的用户线程并发，并且操作系统提供了轻量级进程作为用户线程和内核线程的桥梁，使用内核的调度功能，即用轻量级进程来调度用户线程，用户线程和轻量级进程的数量比例为N:M。 java线程调度 协同式线程调度 &nbsp;&nbsp;&nbsp;&nbsp;线程的执行时间由线程控制，线程完成工作后通知系统切换到另一个线程。优点:实现简单，不存在线程同步的问题。缺点：一个进程不退出cpu时间就会爆炸 抢占式线程调度&nbsp;&nbsp;&nbsp;&nbsp;java使用该方法来调度。线程的执行时间由系统来决定。 ##java线程的6种状态 新建（New）:创建后尚未启动 运行（Runable）：包括running和ready两个状态 状态可能是正在运行或者等待时间片 无限期等待（Waiting）：线程无法获得CPU时间片，必须等待其他线程显示唤醒。 没有设置时间的Object.wait()，Thread.join()方法,LockSupport.park() 限期等待(Timed Waiting) 线程不会被分配CPU时间片也无需被其他线程显示唤醒，到时间自动唤醒。Thread.sleep()方法，设置等待时间的Object.wait()，Thread.join()方法，LockSupport.parkNanos()方法，LockSupport.parkUntil()方法 阻塞(Blocked) 阻塞状态和等待状态的区别是阻塞是等待获取一个排他锁，等待状态是等待唤醒动作的发生，这个过程在线程等待进入同步区域的时候，线程会进入这个状态 结束(Terminated)：线程被终止]]></content>
      <categories>
        <category>JVM虚拟机原理</category>
      </categories>
      <tags>
        <tag>JVM原理</tag>
        <tag>java内存模型</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机 第6章 类文件结构]]></title>
    <url>%2F2018%2F07%2F27%2FJVM-6%2F</url>
    <content type="text"><![CDATA[深入理解Java虚拟机 第六章 类文件结构class类文件的结构 123456789101112131415161718ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; //常量池，字面量和符号引用 u2 access_flags; //访问标志1 u2 this_class; //全限定名 u2 super_class; //父类全限定名 u2 interfaces_count; //接口数量 u2 interfaces[interfaces_count]; //接口的全限定名 u2 fields_count; field_info fields[fields_count]; //类或接口的字段 u2 methods_count; method_info methods[methods_count]; //方法表 u2 attributes_count; attribute_info attributes[attributes_count]; //属性表，code，exception等&#125; class文件是以8字节为基础的二进制流，各个数据都是按一定的顺序排列，如果需要占用8字节以上的空间数据，按照高位在前分割存储 class文件的存储结构只有2种，无符号数和表 无符号数 基本的数据类型，u1,u2,u4,u8类表示1，2，4，8个字节的无符号数，可以描述数字，索引引用，数字量，按UTF-8编码的字符串。 表 是由多个无符号数组成的复合数据类型，所有表以_info结尾，整个class就是一张表 6.2 魔数Class文件的头4个字节，作用：确定这个文件是否为一个能被虚拟机接受的Class文件。值为：0xCAFEBABE(咖啡宝宝) 6.3 版本号紧接着魔数的4个字节。第5，6字节是次版本号，第7，8字节是主版本号 6.4 常量池常量池可以理解为class文件的资源仓库。主要存放了两大类常量：字面量和符号引用。 字面量 string类型的字面量和final类型常量符号引用 包括3中类常量 1.类和接口的全限定名 2.字段的名称和描述符 3.方法的名称和描述符 java在虚拟机加载class文件时才会动态链接，class文件中不会保存各个方法，字段的最终布局，这些字段，方法的符号引用需要在运行时的转换才能得到真正的内存入口。在虚拟机运行时会从常量池中得到对应的符号引用，在类创建时解析。常量池的14中常量结构 比如CONSTANT_CLASS_info,代表类或接口的符号引用，表中的name_index指向CONSTANT_UTF8_info类型的数据，这个存放着我们类的全限定名。 6.5访问标志常量池结束后的两个字节是表示访问标志，用于识别类或者接口的访问信息，比如是类还是接口，访问类型，是否final等等。 6.6类索引，父类索引，接口索引集合class文件由这三个数据来确定类的继承关系。类索引(this_class)和父类索引(super_class)是u2类型的数据，接口索引集合是u2类型的数据集合。 类索引可以确定类的全限定名，父类索引可以确定类的父类全限定名，除了Object类，其他类都有1个父类。接口索引集合按照implements顺序从左到右排列在集合索引中 6.7字段表集合字段表描述类或者接口中申明的变量。字段包括类变量和实例变量，不包括方法内部的局部变量。字段表的格式如下所示，access_flags是字段的访问标志，public，可变性final，并发性violatile等等。其中name_index和descriptor_index是对常量池的引用，代表字段的简单名称和方法的描述符。 全限定名，简单名称，描述符的区别 全限定名是org/fenixsoft/clazz/TestClass是类的全限定名 简单名称 指没有类型和参数修饰符的方法或者字段名称 inc()方法和m字段的简单名称为inc 和m 字段和方法的描述符的解释如下 字段的描述符如下所示对于数组类型，每一维度用[表示，比如java.lang.string[][]的描述符为[[Ljava/lang/String, int[]的描述符为[I描述符描述方法时按照先参数列表再返回值，比如void inc() 表示为()V 方法java.lang.String toString() 表示为 （）Ljava/lang/String ， 方法int indexOf(char[]source, int sourceOffset)可以表示为([CI)I。 6.8方法表集合方法表和字段表类似，结构也是访问标志，名称索引，描述符索引，属性表集合等。 方法的定义在可以通过方法的访问标志，名称索引，描述符索引表达清楚，方法内部的代码是经过java的编译器编译成字节码后存放在方法属性集合中的名为“code”的属性中 在java语言中，重载(override)一个方法，除了和原方法的简单名称一样，还需要和原方法有一个不同的特征签名,特征签名是一个方法中不同参数在常量池中的字段符号引用的合集，所以返回值不会包含在特征签名中，所以无法通过返回值来重载方法 6.9 属性表 code属性java代码经过javac编译后会变成字节码指令存储在code属性中。code属性存放在方法表的属性中，但是不是所有的方法表中都存在code属性，比如接口和抽象类的方法就不存在code属性 max_stack是操作数栈深度的最大值max_locals是局部变量所需的空间 max_locals的单位值slot，slot是虚拟机为局部变量分配内存的最小单位，除了double和long两者是需要2个slot存放，其他的都是1个slot来存放方法参数包括this，异常处理的参数，即try catch中定义的异常，方法体中的局部变量都是用slot来存放。slot可以被复用，只要保证正确性。 code_length和code是存储的字节码exception是方法中可能抛出的受查异常，也就是throws的异常ConstantValue属性是为静态变量赋值 异常表编译器是采用异常表而不是简单的跳转命令来实现java的异常和finally处理机制看出0-9行是正常返回，10-20是exception型的异常返回，21-25是非exception得异常返回。3中路径都有finally中的代码，finally的代码是会嵌套在3种路径的代码之后在return之前。结果是没有异常，返回1，出现exception异常，返回是2，出现exception以外的异常，方法没有返回值。 字节码指令简介 加载和存储指令加载和存储指令将数据在栈帧的局部变量表和操作数栈之间传输 运算指令将连个操作数栈的值进行运算，再将结果存回操作数栈顶 类型转换转换类型，虚拟机直接支持从小范围类型向大范围类型的安全转换，大数到小数就要使用转换指令 对象创建和访问指令new，newarray，访问类字段 getstatic 访问非类字段 getfield 方法调用指令 invokevirtual 调用方法的虚方法，根据方法的实际类型进行分派invokeinterface 调用接口的方法，搜索实现接口方法的实例对象并找出最合适的方法调用invokespecial 调用特殊的方法，比如实力初始化方法和私有方法和父类方法invokespecial 类方法staticinvokedynamic 运行时动态解析出引用的方法。 同步指令java虚拟机支持方法级的同步和方法内部指令的同步，两种的同步结构都是使用管程(Monitor)来支持。比如synchronize的语句实现是monitorenter和monitorexit来实现，执行的线程必须先成功持有管程，然后才能执行方法，方法最后成功或者非正常完成都会释放管程。同步方法在执行时跑出异常，在内部无法处理异常，同步方法持有的管程在异常被抛到同步方法之外时也被自动释放。]]></content>
      <categories>
        <category>JVM虚拟机原理</category>
      </categories>
      <tags>
        <tag>JVM原理</tag>
        <tag>类文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM虚拟机 第7章 虚拟机的类加载机制]]></title>
    <url>%2F2018%2F07%2F12%2FJVM-7%2F</url>
    <content type="text"><![CDATA[虚拟机类加载机制 虚拟机类加载机制虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。Java语言里，类型的加载和连接过程是在程序运行期间完成的。 类加载的时机 类加载的生命周期： 加载 验证 准备 解析 初始化 使用 卸载加载，验证，准备，初始化，卸载的顺序是确定的，为了支持java的动态绑定，解析过程可以在初始化之后调用，即动态绑定或者称为晚期绑定4种必须对类进行“初始化”的情况 new，getstatic，putstatic，invokestatic这4个字节码，对类没有初始化必须先对类进行初始化，即使用new生成对象，读取或者设置类的static变量，final修饰的static变量在编译器把结果放在常量池了除外，调用类的static方法 使用java.lang.reflect包的方法对类进行反射调用 初始化一个类时，其父类未初始化，先触发父类的初始化过程 main方法包含的类要先初始化 被动引用: 通过子类调用父类的静态字段不会导致子类的初始化(对于静态字段，只有直接定义这个字段的类才会被初始化) 通过数组定义应用类 classA[] array = new classA[10]；不会初始化classA，只有该数组去访问classA对象的成员时才会加载类 常量会在编译期间存入调用类的常量池 final字段 123456789101112131415161718192021222324252627//对于static字段，只有直接定义这个字段的类会被加载class A ｛ public static int i = 2;｝class B extends A&#123; public static void main(String[] args) &#123; System.out.println(B.i); &#125; &#125;//数组不会触发类的加载,只有访问i才会加载class A ｛ public static int i = 2;｝class B &#123; public static void main(String[] args) &#123; A[] a = new A[10]; &#125;&#125;//final字段是不会触发A类的加载，会触发B的加载，因为i会被转化成B对自身常量池的引用class A ｛ public static final int i = 2;｝class B &#123; public static void main(String[] args) &#123; System.out.println(A.i); &#125; &#125; java方法的绑定java方法的调用需要先将方法和调用方法的类绑定起来，绑定分为静态绑定和动态绑定： 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。 加载加载是“类加载”的一个过程。加载过程主要完成3件事情： 通过类的全限定名来获取定义类的二进制字节流 将字节流表示的静态存储结果转化成方法区中的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据结构的访问入口 类加载器对任何一个类，需要由它的类加载器和本身的class文件来确定在虚拟机中的唯一性。即一个class文件用两个类加载器加载出来的类是不想等的。equals()，isInstance 等方法的返回结果不同,使用instanceof的返回结果也不同。 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String fileName = name.substring(name.lastIndexOf(".") + 1)+ ".class"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) return super.loadClass(name); byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object obj = myLoader.loadClass("Main").newInstance(); System.out.println(obj.getClass()); //class Main System.out.println(obj instanceof Main); //false Main main = Main.class.newInstance(); System.out.println(main.getClass().isInstance(obj)); //false &#125;&#125; 上述的两个对象一个是使用应用程序类加载器加载的，一个是自定义的类加载器加载，虽然来自同一个clas文件，但是属于两个不同的类。 双亲委派模型 类加载器的层次图如图所示 ,称为类加载器的双亲委派模型, 双亲委派模型要求顶层的启动类加载器外，其余的类均要有自己的父类加载器，而类加载器不是以继承关系实现，而是使用组合的方式来加载父加载器。 123456789101112131415161718192021222324252627@CallerSensitivepublic ClassLoader getClassLoader() &#123; ClassLoader cl = getClassLoader0(); //获取自身classloader if (cl == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; // caller can be null if the VM is requesting it ClassLoader ccl = getClassLoader(caller); //isAncestor方法将类加载器派给了引导类加载器 if(cc1 != null &amp;&amp; cc1 != c1 &amp;&amp; !c1.iaAncestor(cc1)) &#123; sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; &#125; return cl;&#125;//判断c1是不是this的父类加载器 同时c1的引用也会改变，变成c1的parentboolean isAncestor(ClassLoader cl) &#123; ClassLoader acl = this; do &#123; acl = acl.parent; if (cl == acl) &#123; return true; &#125; &#125; while (acl != null); return false;&#125; 启动类加载器 BootStrap ClassLoader用c++编写，该加载器加载java_home/lib的库文件，将库类加载器到虚拟机内存中。启动类加载器无法被java程序使用 扩展类加载器 extension classLoader 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader， 该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序由这三种类加载器配合加载，我们也可以自定义类加载器。因为JVM自带的类加载器只是从本地的文件系统中加载标准的java class文件，使用自己编写的classLoader，可以 执行非致信代码前，自动检验数字签名 动态创建自定义的类 从特定的场所取得java class，比如数据库和网络IO中 双亲委派模型的工作流程一个类加载器收到类加载的请求，不会自己先尝试加载这个类，而是将请求委托类父加载器区完成，所有的类加载器都会传递到顶层的启动类加载器区加载，当父加载器无法找到需要的类时，自加载器才会尝试自己去加载这个类。使用该模型去组织类加载器的好处是java类带有层次性，比如类java.lang.Object存放在JDK\jre\lib下的rt.jar，即(java_home\lib)路径下，最终都会使用启动类加载器区加载，保证了Object类在各个类及载器中都是同一个类。 类加载的验证阶段验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。在idea中的报错的东西都是在这个阶段检查的虚拟机规范：如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个java.lang.VerifyError异常或其子类异常 类加载的准备阶段 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段类变量是static变量，不包括实例变量，这些变量所使用的内存都在方法区中分配。初始值一般指零值 public static int value = 123 在准备阶段后value的值为0，而不是123，在类的初始化阶段才会赋值为123。 public static final int value = 123 final类型的变量在准备阶段就会初始化成指定的值，存在运行时常量池中。 注意点： 对于基本数据类型，static变量和成员变量没有显示赋值会使用默认值，但是局部变量在使用前必须显示赋值，否则编译不通过 static final 类型的变量在申明时必须显示赋值，否则编译不通过。final类型的变量在申明时赋值，或者类初始化后赋值，总之final类型的变量必须显示赋值。static类型的变量在准备阶段会赋零值 对于reference，数组引用，对象引用，没有显示赋值而直接使用，系统会赋null 数组中的元素没有赋值，会使用零值。 1234567891011public class main1 &#123; public static int i; public final int ii; //final可以在构造函数内初始化 public main1() &#123; ii = 1; &#125; public static final int iii; //必须显示初始化，因为static会在准备阶段赋零值 static &#123; iii = 1; //这里赋值也可以，因为都是在准备阶段执行 &#125;&#125; 类加载的解析阶段解析阶段可能在初始化之后，阶段不固定。解析阶段就是将加载的类中常量池里的符号引用转化成直接引用的过程。 符号引用符号引用是用符号来表示引用的对象，只要符号可以无歧义的定位到目标对象即可。目标对象可以在内存中还不存在。 直接引用直接引用时可以直接指向目标中的指针，相对偏移量或者能间接定位到目标的句柄。直接引用的目标在内存中必须存在。A.f1(),符号引用指的是方法区中的偏移量，直接引用指的是直接指向类的方法的入口地址，f1()具体的方法地址 类的解析当前的类为D，将一个符号引用N解析为类或接口C的直接引用，1 C N = new D() 如果C不是数组类型，那么会将N的权限定名给D，用D的类加载器去加载。2 C[] N = new D[100] C时数组类型，不会去启动D的类加载器去加载，但是虚拟机会生成一个表示这个数组的对象。 字段解析对字段表中的class_index的索引中的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或者接口的符号引用。比如在方法里调用了C.a 将字段所属的类定义为C如果C本身存在字段a，直接返回a的直接引用。如果C实现了借口，按照继承关系从下往上递归搜索各个接口和父接口，找到字段a的直接引用。如果C不是Object，则从下往上递归搜索父类中的字段，直到找到a都没有找到，抛出异常 类方法解析 C.a()解析先在类方法表中的索引的方法所属的类或者接口的符号引用。在C中找到a的直接引用。否则在C的父类中找到和这个方法的直接引用，查找结束。否则在C的接口中找到这个方法的引用，如果存在，说明C是抽象类，则查找结束，抛出异常。 接口方法解析 c.a() c是一个接口则先查c自身的接口，没有就查父接口 ，直到查到a的直接引用。类加载的初始化阶段类初始化阶段是类加载过程的最后一步，在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。在初始化阶段实际是执行类构造器的方法&lt;clinit&gt;()方法， &lt;clinit&gt;()会由编译器自动收集类中的类变量的赋值动作和静态语句块(static{}块)语句合并，并且顺序由原文件的顺序决定。静态语句块中只能给访问到静态语句块之前的变量，在它之后的变量可以访问，但是不能赋值 1234567public class Test &#123; static &#123; i = 0; //给变量赋值可以正常编译通过 System.out.print(i); //编译器会提示“非法向前引用” &#125; static int i = 1;&#125; &lt;clinit&gt;()和类的实例构造器不同&lt;init&gt;()，它不需要显示调用父类的构造器，虚拟机会保证在子类初始化之前父类已经初始化完毕。因此虚拟机中第一个被执行&lt;init&gt;()一定是java.lang.Object类。 父类的static代码块一定会优先于子类的static代码块先执行。 &lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。 接口中不能使用静态语句块，但仍然有变量初始化的操作，因此接口与类一样都会生成&lt;clinit&gt;()方法，但与类不同的是，执行接口的初始化方法之前，不需要先执行父接口的初始化方法。只有当父接口中定义的变量使用时，才会执行父接口的初始化方法。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待，直到活动线程执行类初始化方法完毕。 很简单，下面代码执行的结果为2，而不是1 12345678910111213static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125; &#125;static class Sub extends Parent &#123; public static int B = A; &#125;public static void main(String[] args) &#123; System.out.println(Sub.B); &#125;]]></content>
      <categories>
        <category>JVM虚拟机原理</category>
      </categories>
      <tags>
        <tag>JVM原理</tag>
        <tag>虚拟机类加载机制</tag>
      </tags>
  </entry>
</search>
